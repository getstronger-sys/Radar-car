Index: viz/roboviz_slam_viz.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport sys\r\nimport os\r\n\r\n# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°è·¯å¾„ï¼Œè§£å†³å¯¼å…¥é—®é¢˜\r\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\r\n\r\nfrom roboviz import MapVisualizer\r\n\r\n# å¯¼å…¥å…¨å±€å‚æ•°\r\nfrom config.settings import MAP_SIZE_M, MAP_RESOLUTION\r\nfrom config.map import MAP_SIZE\r\n\r\nimport matplotlib.patches as mpatches\r\n\r\nclass RoboVizSLAMViewer:\r\n    def __init__(self, title='RoboViz SLAM Viewer', map_size_pixels=None, map_size_meters=None, use_mm=False):\r\n        \"\"\"\r\n        å¢å¼ºç‰ˆ PyRoboViz SLAM å¯è§†åŒ–\r\n        - æ”¯æŒæ¯«ç±³å•ä½å¤§åœ°å›¾æ˜¾ç¤º\r\n        - æ¯å¸§ç”»å‡ºæ¿€å…‰å°„çº¿\r\n        - æœºå™¨äººç”¨ä¸‰è§’å½¢è¡¨ç¤º\r\n        - åæ ‡è½´å•ä½å’ŒèŒƒå›´å¯è‡ªå®šä¹‰\r\n        - æ–°å¢ï¼šå‰æ²¿ç‚¹å¯è§†åŒ–ã€æµç•…åŠ¨ç”»æ›´æ–°\r\n        \"\"\"\r\n        self.use_mm = use_mm\r\n        if use_mm:\r\n            self.map_size_pixels = int(MAP_SIZE_M * 1000) if map_size_pixels is None else map_size_pixels\r\n            self.map_size_meters = MAP_SIZE_M * 1000 if map_size_meters is None else map_size_meters\r\n            self.resolution = 1.0  # 1mm/åƒç´ \r\n        else:\r\n            self.map_size_pixels = map_size_pixels or MAP_SIZE\r\n            self.map_size_meters = map_size_meters or MAP_SIZE_M\r\n            self.resolution = MAP_RESOLUTION\r\n        self.title = title\r\n\r\n        self.viz = MapVisualizer(\r\n            map_size_pixels=self.map_size_pixels,\r\n            map_size_meters=self.map_size_meters,\r\n            title=title,\r\n            show_trajectory=False\r\n        )\r\n        \r\n        # å¯è§†åŒ–å…ƒç´ \r\n        self.traj_line = None\r\n        self.path_line = None\r\n        self.lidar_points = None\r\n        self.laser_lines = []\r\n        self.robot_patch = None\r\n        self.obstacle_points = None\r\n        self.frontier_points = None  # æ–°å¢ï¼šå‰æ²¿ç‚¹\r\n        self.current_goal = None     # æ–°å¢ï¼šå½“å‰ç›®æ ‡ç‚¹\r\n        self.status_text = None      # æ–°å¢ï¼šçŠ¶æ€æ–‡æœ¬\r\n        \r\n        # åŠ¨ç”»æ§åˆ¶\r\n        self.frame_count = 0\r\n        self.last_update_time = 0\r\n        \r\n        # è®¾ç½®matplotlibä¸ºäº¤äº’æ¨¡å¼ï¼Œæé«˜åŠ¨ç”»æ€§èƒ½\r\n        import matplotlib.pyplot as plt\r\n        plt.ion()\r\n\r\n    def update(self, map_bytes, pose, lidar_scan=None, trajectory=None, nav_path=None, \r\n               frontiers=None, current_goal=None, status_info=None):\r\n        \"\"\"\r\n        æ›´æ–°å¯è§†åŒ–æ˜¾ç¤º\r\n        \r\n        å‚æ•°ï¼š\r\n        - map_bytes: SLAMåœ°å›¾æ•°æ®\r\n        - pose: æœºå™¨äººä½å§¿ [x, y, theta]\r\n        - lidar_scan: æ¿€å…‰æ‰«ææ•°æ®\r\n        - trajectory: è½¨è¿¹ç‚¹åˆ—è¡¨\r\n        - nav_path: å¯¼èˆªè·¯å¾„\r\n        - frontiers: å‰æ²¿ç‚¹åˆ—è¡¨ [(x1, y1), (x2, y2), ...]\r\n        - current_goal: å½“å‰ç›®æ ‡ç‚¹ (x, y)\r\n        - status_info: çŠ¶æ€ä¿¡æ¯å­—å…¸\r\n        \"\"\"\r\n        x, y, theta = pose\r\n        theta_deg = np.degrees(theta)\r\n        \r\n        # å•ä½è½¬æ¢\r\n        if self.use_mm:\r\n            x_mm = x * 1000\r\n            y_mm = y * 1000\r\n        else:\r\n            x_mm = x\r\n            y_mm = y\r\n            \r\n        # æ›´æ–°SLAMåœ°å›¾\r\n        self.viz.display(x_mm, y_mm, theta_deg, map_bytes)\r\n\r\n        # æ¸…ç†æ—§çš„æ¿€å…‰å°„çº¿\r\n        for line in self.laser_lines:\r\n            try:\r\n                line.remove()\r\n            except Exception:\r\n                pass\r\n        self.laser_lines = []\r\n\r\n        # ç»˜åˆ¶æ¿€å…‰å°„çº¿\r\n        if lidar_scan is not None:\r\n            scan_angles = np.linspace(0, 2*np.pi, len(lidar_scan), endpoint=False)\r\n            scan_dist = np.array(lidar_scan)\r\n            if not self.use_mm:\r\n                scan_dist = scan_dist / 1000.0  # è½¬ç±³\r\n            valid = (scan_dist > 0) & (scan_dist < (4000 if self.use_mm else 4.0))\r\n            scan_angles = scan_angles[valid]\r\n            scan_dist = scan_dist[valid]\r\n            \r\n            for r, a in zip(scan_dist, scan_angles):\r\n                if self.use_mm:\r\n                    end_x = x_mm + r * np.cos(theta + a)\r\n                    end_y = y_mm + r * np.sin(theta + a)\r\n                else:\r\n                    end_x = x + r * np.cos(theta + a)\r\n                    end_y = y + r * np.sin(theta + a)\r\n                # ç”»å°„çº¿ - ä½¿ç”¨çº¢è‰²ï¼Œæ›´é†’ç›®\r\n                line, = self.viz.ax.plot([x_mm, end_x], [y_mm, end_y], \r\n                                       color='red', linewidth=0.5, alpha=0.6, zorder=2)\r\n                self.laser_lines.append(line)\r\n\r\n        # æ›´æ–°è½¨è¿¹\r\n        if self.traj_line:\r\n            self.traj_line.remove()\r\n            self.traj_line = None\r\n        if trajectory and len(trajectory) > 1:\r\n            if self.use_mm:\r\n                traj_x = [p[0]*1000 for p in trajectory]\r\n                traj_y = [p[1]*1000 for p in trajectory]\r\n            else:\r\n                traj_x = [p[0] for p in trajectory]\r\n                traj_y = [p[1] for p in trajectory]\r\n            self.traj_line, = self.viz.ax.plot(traj_x, traj_y, 'blue', \r\n                                             linewidth=1.5, alpha=0.8, zorder=4, \r\n                                             label='Robot Trajectory')\r\n\r\n        # æ›´æ–°å¯¼èˆªè·¯å¾„\r\n        if self.path_line:\r\n            self.path_line.remove()\r\n            self.path_line = None\r\n        if nav_path and len(nav_path) > 1:\r\n            if self.use_mm:\r\n                path_x = [p[0]*1000 for p in nav_path]\r\n                path_y = [p[1]*1000 for p in nav_path]\r\n            else:\r\n                path_x = [p[0] for p in nav_path]\r\n                path_y = [p[1] for p in nav_path]\r\n            self.path_line, = self.viz.ax.plot(path_x, path_y, 'green', \r\n                                             linewidth=2, alpha=0.7, zorder=3, \r\n                                             linestyle='--', label='Navigation Path')\r\n\r\n        # æ›´æ–°å‰æ²¿ç‚¹\r\n        if self.frontier_points:\r\n            self.frontier_points.remove()\r\n            self.frontier_points = None\r\n        if frontiers and len(frontiers) > 0:\r\n            if self.use_mm:\r\n                frontier_x = [f[0]*1000 for f in frontiers]\r\n                frontier_y = [f[1]*1000 for f in frontiers]\r\n            else:\r\n                frontier_x = [f[0] for f in frontiers]\r\n                frontier_y = [f[1] for f in frontiers]\r\n            self.frontier_points = self.viz.ax.scatter(frontier_x, frontier_y, \r\n                                                     c='yellow', s=30, alpha=0.8, \r\n                                                     edgecolors='orange', linewidth=1,\r\n                                                     label='Frontiers', zorder=5)\r\n\r\n        # æ›´æ–°å½“å‰ç›®æ ‡ç‚¹\r\n        if self.current_goal:\r\n            self.current_goal.remove()\r\n            self.current_goal = None\r\n        if current_goal:\r\n            if self.use_mm:\r\n                goal_x = current_goal[0] * 1000\r\n                goal_y = current_goal[1] * 1000\r\n            else:\r\n                goal_x = current_goal[0]\r\n                goal_y = current_goal[1]\r\n            self.current_goal = self.viz.ax.scatter(goal_x, goal_y, \r\n                                                  c='magenta', s=100, alpha=0.9,\r\n                                                  edgecolors='purple', linewidth=2,\r\n                                                  marker='*', label='Current Goal', zorder=6)\r\n\r\n        # æ›´æ–°æœºå™¨äººä¸‰è§’å½¢\r\n        if self.robot_patch:\r\n            self.robot_patch.remove()\r\n            self.robot_patch = None\r\n        # æœºå™¨äººä¸‰è§’å½¢å‚æ•°\r\n        tri_len = 200 if self.use_mm else 0.2  # 20cm\r\n        tri_wid = 100 if self.use_mm else 0.1  # 10cm\r\n        # æœºå™¨äººæœå‘ä¸‰è§’å½¢é¡¶ç‚¹\r\n        tip = (x_mm + tri_len * np.cos(theta), y_mm + tri_len * np.sin(theta))\r\n        left = (x_mm + tri_wid * np.cos(theta + 2.5), y_mm + tri_wid * np.sin(theta + 2.5))\r\n        right = (x_mm + tri_wid * np.cos(theta - 2.5), y_mm + tri_wid * np.sin(theta - 2.5))\r\n        triangle = np.array([tip, left, right])\r\n        self.robot_patch = mpatches.Polygon(triangle, color='red', zorder=10)\r\n        self.viz.ax.add_patch(self.robot_patch)\r\n\r\n        # æ›´æ–°çŠ¶æ€æ–‡æœ¬\r\n        if self.status_text:\r\n            self.status_text.remove()\r\n            self.status_text = None\r\n        if status_info:\r\n            status_str = f\"Frame: {self.frame_count}\\n\"\r\n            for key, value in status_info.items():\r\n                status_str += f\"{key}: {value}\\n\"\r\n            self.status_text = self.viz.ax.text(0.02, 0.98, status_str,\r\n                                              transform=self.viz.ax.transAxes,\r\n                                              verticalalignment='top',\r\n                                              bbox=dict(boxstyle='round', facecolor='white', alpha=0.8),\r\n                                              fontsize=8, zorder=20)\r\n\r\n        # æ›´æ–°å›¾ä¾‹\r\n        if not self.viz.ax.get_legend():\r\n            self.viz.ax.legend(loc='upper right', fontsize=8)\r\n\r\n        # æ›´æ–°è®¡æ•°\r\n        self.frame_count += 1\r\n\r\n    def add_obstacle_points(self, obstacle_points):\r\n        \"\"\"\r\n        æ·»åŠ éšœç¢ç‰©ç‚¹å¯è§†åŒ–\r\n        \r\n        å‚æ•°ï¼š\r\n        - obstacle_points: [(x1, y1), (x2, y2), ...] éšœç¢ç‰©ç‚¹åˆ—è¡¨\r\n        \"\"\"\r\n        if self.obstacle_points:\r\n            self.obstacle_points.remove()\r\n            self.obstacle_points = None\r\n        \r\n        if obstacle_points and len(obstacle_points) > 0:\r\n            if self.use_mm:\r\n                obs_x = [p[0]*1000 for p in obstacle_points]\r\n                obs_y = [p[1]*1000 for p in obstacle_points]\r\n            else:\r\n                obs_x = [p[0] for p in obstacle_points]\r\n                obs_y = [p[1] for p in obstacle_points]\r\n            \r\n            self.obstacle_points = self.viz.ax.scatter(obs_x, obs_y, \r\n                                                     c='black', s=20, alpha=0.8,\r\n                                                     label='Obstacles', zorder=1)\r\n\r\n    def save_map(self, filename='roboviz_slam_map.png'):\r\n        \"\"\"\r\n        ä¿å­˜å½“å‰åœ°å›¾ä¸ºå›¾ç‰‡\r\n        \"\"\"\r\n        try:\r\n            if hasattr(self.viz, 'fig'):\r\n                self.viz.fig.savefig(filename, dpi=150, bbox_inches='tight')  # type: ignore\r\n            elif hasattr(self.viz, 'figure'):\r\n                self.viz.figure.savefig(filename, dpi=150, bbox_inches='tight')  # type: ignore\r\n            elif hasattr(self.viz, 'ax'):\r\n                self.viz.ax.figure.savefig(filename, dpi=150, bbox_inches='tight')  # type: ignore\r\n            else:\r\n                import matplotlib.pyplot as plt\r\n                plt.savefig(filename, dpi=150, bbox_inches='tight')\r\n            print(f\"âœ… åœ°å›¾å·²ä¿å­˜: {filename}\")\r\n        except Exception as e:\r\n            print(f\"âŒ ä¿å­˜åœ°å›¾å¤±è´¥: {e}\")\r\n\r\n    def close(self):\r\n        \"\"\"\r\n        å…³é—­å¯è§†åŒ–çª—å£\r\n        \"\"\"\r\n        try:\r\n            if hasattr(self.viz, 'close'):\r\n                self.viz.close()\r\n            else:\r\n                import matplotlib.pyplot as plt\r\n                plt.close('all')\r\n        except Exception as e:\r\n            print(f\"å…³é—­å¯è§†åŒ–çª—å£æ—¶å‡ºé”™: {e}\")\r\n\r\n    def show(self):\r\n        \"\"\"\r\n        æ˜¾ç¤ºå¯è§†åŒ–çª—å£\r\n        \"\"\"\r\n        try:\r\n            if hasattr(self.viz, 'show'):\r\n                self.viz.show()\r\n            else:\r\n                import matplotlib.pyplot as plt\r\n                plt.show()\r\n        except Exception as e:\r\n            print(f\"æ˜¾ç¤ºå¯è§†åŒ–çª—å£æ—¶å‡ºé”™: {e}\")\r\n\r\n    def get_frame_rate(self):\r\n        \"\"\"\r\n        è·å–å½“å‰å¸§ç‡\r\n        \"\"\"\r\n        import time\r\n        current_time = time.time()\r\n        if self.last_update_time > 0:\r\n            fps = 1.0 / (current_time - self.last_update_time)\r\n        else:\r\n            fps = 0\r\n        self.last_update_time = current_time\r\n        return fps\r\n\r\n\r\ndef test_roboviz_viewer():\r\n    \"\"\"\r\n    æµ‹è¯•RoboViz SLAMå¯è§†åŒ–å™¨\r\n    \"\"\"\r\n    import time\r\n    \r\n    # åˆ›å»ºå¯è§†åŒ–å™¨\r\n    viewer = RoboVizSLAMViewer(title='Test SLAM Viewer', use_mm=False)\r\n    \r\n    # æ¨¡æ‹Ÿæ•°æ®\r\n    map_bytes = bytearray(MAP_SIZE * MAP_SIZE)\r\n    pose = [MAP_SIZE_M/2, MAP_SIZE_M/2, 0.0]  # åœ°å›¾ä¸­å¿ƒ\r\n    \r\n    # æ¨¡æ‹Ÿæ¿€å…‰æ‰«ææ•°æ®\r\n    lidar_scan = [1000 + i * 50 for i in range(360)]\r\n    \r\n    # æ¨¡æ‹Ÿè½¨è¿¹\r\n    trajectory = []\r\n    for i in range(10):\r\n        x = MAP_SIZE_M/2 + i * 0.3\r\n        y = MAP_SIZE_M/2 + i * 0.1\r\n        theta = i * 0.1\r\n        trajectory.append([x, y])\r\n    \r\n    # æ¨¡æ‹Ÿå‰æ²¿ç‚¹\r\n    frontiers = [[1.0, 1.0], [2.0, 2.0], [3.0, 1.5]]\r\n    \r\n    # æ¨¡æ‹Ÿç›®æ ‡ç‚¹\r\n    current_goal = [MAP_SIZE_M-1, MAP_SIZE_M-1]\r\n    \r\n    # æ›´æ–°å¯è§†åŒ–\r\n    viewer.update(map_bytes, pose, lidar_scan, trajectory, None, frontiers, current_goal)\r\n    \r\n    print(\"âœ… RoboViz SLAMå¯è§†åŒ–å™¨æµ‹è¯•å®Œæˆ\")\r\n    print(f\"åœ°å›¾å°ºå¯¸: {MAP_SIZE}x{MAP_SIZE} åƒç´ \")\r\n    print(f\"åœ°å›¾ç‰©ç†å°ºå¯¸: {MAP_SIZE_M}x{MAP_SIZE_M} ç±³\")\r\n    print(f\"åˆ†è¾¨ç‡: {MAP_RESOLUTION} ç±³/åƒç´ \")\r\n    \r\n    # ä¿å­˜æµ‹è¯•å›¾ç‰‡\r\n    viewer.save_map('test_slam_map.png')\r\n    \r\n    return viewer\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    # è¿è¡Œæµ‹è¯•\r\n    viewer = test_roboviz_viewer()\r\n    viewer.show() 
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/viz/roboviz_slam_viz.py b/viz/roboviz_slam_viz.py
--- a/viz/roboviz_slam_viz.py	(revision 298ac29f37e3999bd2e2504354a68a98f8c62904)
+++ b/viz/roboviz_slam_viz.py	(date 1751471882912)
@@ -1,348 +1,1117 @@
-import numpy as np
 import sys
 import os
 
-# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°è·¯å¾„ï¼Œè§£å†³å¯¼å…¥é—®é¢˜
-sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
+# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°Pythonè·¯å¾„
+project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
+sys.path.append(project_root)
+
+import numpy as np
+import json
+import math
+from collections import deque
+import matplotlib.pyplot as plt
+import matplotlib.animation as animation
+from matplotlib.patches import Circle, FancyArrow, Rectangle
+from scipy.ndimage import label, binary_dilation
+import time
+import heapq
+from config.map import get_global_map, MAP_RESOLUTION
+from config.settings import START_POSITION
+
+# æ·»åŠ breezyslamç›¸å…³å¯¼å…¥
+try:
+    from breezyslam.algorithms import RMHC_SLAM
+    from breezyslam.sensors import Laser
+    BREEZYSLAM_AVAILABLE = True
+except ImportError:
+    print("è­¦å‘Š: breezyslamåº“æœªå®‰è£…ï¼ŒSLAMåŠŸèƒ½å°†ä¸å¯ç”¨")
+    BREEZYSLAM_AVAILABLE = False
+
+# ==================== SLAMç±»å®šä¹‰ ====================
+class CarSLAM:
+    def __init__(self, map_size_pixels=500, map_size_meters=20):
+        if not BREEZYSLAM_AVAILABLE:
+            self.available = False
+            return
+            
+        self.available = True
+        # åˆå§‹åŒ–æ¿€å…‰æ¨¡å‹ï¼ˆé€‚é…360ä¸ªæ¿€å…‰æŸï¼‰
+        self.laser = Laser(scan_size=360, scan_rate_hz=10, detection_angle_degrees=360,
+                           distance_no_detection_mm=0, detection_margin=0, offset_mm=0)
+        # åˆå§‹åŒ–SLAMå¯¹è±¡
+        self.slam = RMHC_SLAM(self.laser, map_size_pixels, map_size_meters)
+        self.mapbytes = bytearray(map_size_pixels * map_size_pixels)
+        self.map_size_pixels = map_size_pixels
+        self.map_size_meters = map_size_meters
+        
+        # åˆå§‹åŒ–ä½ç½®ä¼°è®¡
+        self.x_mm = START_POSITION['x'] * 1000  # è½¬æ¢ä¸ºæ¯«ç±³
+        self.y_mm = START_POSITION['y'] * 1000
+        self.theta_degrees = np.degrees(START_POSITION['theta'])
+
+    def update_position(self, lidar_scan, pose_change):
+        """æ›´æ–°SLAMä½ç½®å’Œåœ°å›¾"""
+        if not self.available:
+            return None, None, None
+            
+        # è½¬æ¢æ¿€å…‰æ•°æ®æ ¼å¼ï¼ˆä»ç±³è½¬æ¢ä¸ºæ¯«ç±³ï¼‰ï¼Œå¹¶å¤„ç†æœ€å¤§è·ç¦»æƒ…å†µ
+        lidar_scan_mm = []
+        for dist in lidar_scan:
+            if dist >= 4.8:  # å¦‚æœè·ç¦»æ¥è¿‘æˆ–ç­‰äºæœ€å¤§æ¢æµ‹è·ç¦»ï¼ˆ5ç±³ï¼‰ï¼Œä½¿ç”¨0è¡¨ç¤ºæ— æ£€æµ‹
+                lidar_scan_mm.append(0)
+            else:
+                lidar_scan_mm.append(int(dist * 1000))
+        
+        # æ›´æ–°SLAMï¼ˆä¼ å…¥é‡Œç¨‹è®¡æ•°æ®ï¼‰
+        self.slam.update(lidar_scan_mm, pose_change)
+        
+        # è·å–æ›´ç²¾ç¡®çš„ä½ç½®
+        self.x_mm, self.y_mm, self.theta_degrees = self.slam.getpos()
+        
+        # æ›´æ–°åœ°å›¾
+        self.slam.getmap(self.mapbytes)
+        
+        return self.x_mm / 1000, self.y_mm / 1000, np.radians(self.theta_degrees)
+    
+
+
+    def get_map_array(self):
+        """è·å–åœ°å›¾æ•°ç»„ç”¨äºæ˜¾ç¤º"""
+        if not self.available:
+            return None
+            
+        # å°†å­—èŠ‚æ•°ç»„è½¬æ¢ä¸ºnumpyæ•°ç»„
+        map_array = np.array(self.mapbytes, dtype=np.uint8)
+        map_array = map_array.reshape(self.map_size_pixels, self.map_size_pixels)
+        
+        # è½¬æ¢ä¸º0-1èŒƒå›´ï¼ˆ0ä¸ºç©ºç™½ï¼Œ1ä¸ºéšœç¢ç‰©ï¼‰
+        map_array = map_array.astype(float) / 255.0
+        
+        return map_array
+
+
+class LidarScan:
+    def __init__(self, ranges, angles, timestamp):
+        self.ranges = ranges
+        self.angles = angles
+        self.timestamp = timestamp
+
+
+class Odometry:
+    def __init__(self, x, y, theta, timestamp):
+        self.x = x
+        self.y = y
+        self.theta = theta
+        self.timestamp = timestamp
+
+
+class Robot:
+    def __init__(self, x, y, theta=0):
+        self.x = x
+        self.y = y
+        self.theta = theta
+        self.max_speed = 0.5
+        self.max_angular_speed = 1.0
+        self.radius = 0.15
+
+    def is_position_safe(self, x, y, occupancy_grid, resolution, safety_margin=0.15):
+        """Check if position is safe (no collision with obstacles)"""
+        margin_cells = int(safety_margin / resolution)
+        gx = int(x / resolution)
+        gy = int(y / resolution)
+
+        for dx in range(-margin_cells, margin_cells + 1):
+            for dy in range(-margin_cells, margin_cells + 1):
+                check_x = gx + dx
+                check_y = gy + dy
 
-from roboviz import MapVisualizer
+                if (check_x < 0 or check_x >= occupancy_grid.shape[1] or
+                        check_y < 0 or check_y >= occupancy_grid.shape[0]):
+                    return False
 
-# å¯¼å…¥å…¨å±€å‚æ•°
-from config.settings import MAP_SIZE_M, MAP_RESOLUTION
-from config.map import MAP_SIZE
+                if occupancy_grid[check_y, check_x] > 0.5:
+                    return False
 
-import matplotlib.patches as mpatches
+        return True
 
-class RoboVizSLAMViewer:
-    def __init__(self, title='RoboViz SLAM Viewer', map_size_pixels=None, map_size_meters=None, use_mm=False):
-        """
-        å¢å¼ºç‰ˆ PyRoboViz SLAM å¯è§†åŒ–
-        - æ”¯æŒæ¯«ç±³å•ä½å¤§åœ°å›¾æ˜¾ç¤º
-        - æ¯å¸§ç”»å‡ºæ¿€å…‰å°„çº¿
-        - æœºå™¨äººç”¨ä¸‰è§’å½¢è¡¨ç¤º
-        - åæ ‡è½´å•ä½å’ŒèŒƒå›´å¯è‡ªå®šä¹‰
-        - æ–°å¢ï¼šå‰æ²¿ç‚¹å¯è§†åŒ–ã€æµç•…åŠ¨ç”»æ›´æ–°
-        """
-        self.use_mm = use_mm
-        if use_mm:
-            self.map_size_pixels = int(MAP_SIZE_M * 1000) if map_size_pixels is None else map_size_pixels
-            self.map_size_meters = MAP_SIZE_M * 1000 if map_size_meters is None else map_size_meters
-            self.resolution = 1.0  # 1mm/åƒç´ 
+    def move_to_position(self, target_x, target_y, occupancy_grid=None, resolution=None):
+        """Safely move to target position"""
+        if occupancy_grid is not None and resolution is not None:
+            if not self.is_position_safe(target_x, target_y, occupancy_grid, resolution):
+                return False
+
+        if hasattr(self, 'last_x') and hasattr(self, 'last_y'):
+            dx = target_x - self.last_x
+            dy = target_y - self.last_y
+            if abs(dx) > 0.001 or abs(dy) > 0.001:
+                self.theta = math.atan2(dy, dx)
+
+        self.last_x = self.x
+        self.last_y = self.y
+        self.x = target_x
+        self.y = target_y
+        return True
+
+    def normalize_angle(self, angle):
+        """Normalize angle to [-pi, pi]"""
+        while angle > math.pi:
+            angle -= 2 * math.pi
+        while angle < -math.pi:
+            angle += 2 * math.pi
+        return angle
+
+
+class MapConverter:
+    def __init__(self, resolution=0.05):
+        self.resolution = resolution
+
+    def segments_to_occupancy_grid(self, segments, map_size=(16, 16)):
+        """Convert line segments to occupancy grid with boundaries"""
+        width = int(map_size[0] / self.resolution)
+        height = int(map_size[1] / self.resolution)
+
+        grid = np.zeros((height, width), dtype=np.float32)
+        self._add_boundary_walls(grid, map_size)
+
+        for segment in segments:
+            self._draw_line(grid, segment['start'], segment['end'])
+
+        return grid
+
+    def _add_boundary_walls(self, grid, map_size):
+        """Add boundary walls around the map"""
+        height, width = grid.shape
+        grid[0, :] = 1.0  # Top boundary
+        grid[height - 1, :] = 1.0  # Bottom boundary
+        grid[:, 0] = 1.0  # Left boundary
+        grid[:, width - 1] = 1.0  # Right boundary
+
+    def _draw_line(self, grid, start, end):
+        """Draw a line on the grid using Bresenham's algorithm"""
+        x0 = int(start[0] / self.resolution)
+        y0 = int(start[1] / self.resolution)
+        x1 = int(end[0] / self.resolution)
+        y1 = int(end[1] / self.resolution)
+
+        points = self._bresenham_line(x0, y0, x1, y1)
+
+        for x, y in points:
+            if 0 <= x < grid.shape[1] and 0 <= y < grid.shape[0]:
+                grid[y, x] = 1.0
+
+    def _bresenham_line(self, x0, y0, x1, y1):
+        """Bresenham's line algorithm"""
+        points = []
+        dx = abs(x1 - x0)
+        dy = abs(y1 - y0)
+        x, y = x0, y0
+        n = 1 + dx + dy
+        x_inc = 1 if x1 > x0 else -1
+        y_inc = 1 if y1 > y0 else -1
+        error = dx - dy
+
+        dx *= 2
+        dy *= 2
+
+        for _ in range(n):
+            points.append((x, y))
+
+            if error > 0:
+                x += x_inc
+                error -= dy
+            else:
+                y += y_inc
+                error += dx
+
+        return points
+
+
+class LidarSimulator:
+    def __init__(self, range_max=5.0, num_beams=360, angle_res=1):
+        self.range_max = range_max
+        self.num_beams = num_beams
+        self.angle_res = angle_res
+        self.angles = np.linspace(0, 2 * np.pi, num_beams, endpoint=False)
+
+    def scan(self, robot_pos, occupancy_grid, resolution):
+        """Simulate lidar scan"""
+        ranges = []
+        robot_x, robot_y, robot_theta = robot_pos
+
+        for angle in self.angles:
+            global_angle = robot_theta + angle
+            range_val = self._cast_ray_fast(
+                robot_x, robot_y, global_angle,
+                occupancy_grid, resolution
+            )
+            ranges.append(range_val)
+
+        return LidarScan(ranges, self.angles.tolist(), 0)
+
+    def _cast_ray_fast(self, start_x, start_y, angle, grid, resolution):
+        """Fast ray casting"""
+        step_size = resolution * 0.5
+        max_steps = int(self.range_max / step_size)
+
+        cos_a = math.cos(angle)
+        sin_a = math.sin(angle)
+
+        for step in range(max_steps):
+            x = start_x + step * step_size * cos_a
+            y = start_y + step * step_size * sin_a
+
+            gx = int(x / resolution)
+            gy = int(y / resolution)
+
+            if (gx < 0 or gx >= grid.shape[1] or
+                    gy < 0 or gy >= grid.shape[0]):
+                return step * step_size
+
+            if grid[gy, gx] > 0.5:
+                return step * step_size
+
+        return self.range_max
+
+
+def detect_frontiers_optimized(occupancy_grid, unknown_val=-1, free_threshold=0.2, map_resolution=0.01):
+    """Optimized frontier detection function"""
+    h, w = occupancy_grid.shape
+
+    free_mask = (occupancy_grid >= 0) & (occupancy_grid < free_threshold)
+    unknown_mask = (occupancy_grid == unknown_val)
+
+    dilated_unknown = binary_dilation(unknown_mask, structure=np.ones((3, 3)))
+    frontiers_mask = free_mask & dilated_unknown
+    labeled, num_features = label(frontiers_mask)
+
+    frontiers_world = []
+
+    for i in range(1, num_features + 1):
+        ys, xs = np.where(labeled == i)
+
+        if len(xs) > 3:
+            cx = int(np.mean(xs))
+            cy = int(np.mean(ys))
+            x_m = cx * map_resolution
+            y_m = cy * map_resolution
+            frontiers_world.append((x_m, y_m))
+
+    return frontiers_world
+
+
+def select_best_frontier(frontiers, robot_pos, occupancy_grid, map_resolution, path_planner=None):
+    """Select best frontier based on path distance"""
+    if not frontiers:
+        return None
+
+    distances = []
+    valid_frontiers = []
+
+    for frontier in frontiers:
+        if path_planner:
+            path = path_planner.plan(robot_pos, frontier, occupancy_grid)
+            if path:
+                path_length = 0
+                for i in range(1, len(path)):
+                    dx = path[i][0] - path[i - 1][0]
+                    dy = path[i][1] - path[i - 1][1]
+                    path_length += np.hypot(dx, dy)
+                distances.append(path_length)
+                valid_frontiers.append(frontier)
+            else:
+                distances.append(float('inf'))
+                valid_frontiers.append(frontier)
         else:
-            self.map_size_pixels = map_size_pixels or MAP_SIZE
-            self.map_size_meters = map_size_meters or MAP_SIZE_M
-            self.resolution = MAP_RESOLUTION
-        self.title = title
+            distance = np.hypot(frontier[0] - robot_pos[0], frontier[1] - robot_pos[1])
+            distances.append(distance)
+            valid_frontiers.append(frontier)
+
+    if not valid_frontiers:
+        return None
+
+    min_index = np.argmin(distances)
+    return valid_frontiers[min_index]
+
+
+def world_to_grid(x, y, resolution):
+    """Convert world coordinates to grid coordinates"""
+    return int(x / resolution), int(y / resolution)
+
+
+def grid_to_world(gx, gy, resolution):
+    """Convert grid coordinates to world coordinates"""
+    return (gx + 0.5) * resolution, (gy + 0.5) * resolution
+
+
+class AStarPathPlanner:
+    """A* path planning algorithm with safety margins"""
+
+    def __init__(self, resolution, safety_margin=0.15):
+        self.resolution = resolution
+        self.safety_margin = safety_margin
+
+    def is_valid_position(self, gx, gy, occupancy_grid):
+        """Check if position is valid with safety margin"""
+        margin_cells = int(self.safety_margin / self.resolution)
+
+        for dx in range(-margin_cells, margin_cells + 1):
+            for dy in range(-margin_cells, margin_cells + 1):
+                check_x = gx + dx
+                check_y = gy + dy
+
+                if (check_x < 0 or check_x >= occupancy_grid.shape[1] or
+                        check_y < 0 or check_y >= occupancy_grid.shape[0]):
+                    return False
+
+                if occupancy_grid[check_y, check_x] > 0.5:
+                    return False
+
+        return True
+
+    def plan(self, start, goal, occupancy_grid):
+        """Plan path from start to goal using A*"""
+        sx, sy = world_to_grid(start[0], start[1], self.resolution)
+        gx, gy = world_to_grid(goal[0], goal[1], self.resolution)
+
+        if not self.is_valid_position(sx, sy, occupancy_grid):
+            return None
+        if not self.is_valid_position(gx, gy, occupancy_grid):
+            return None
+
+        open_set = []
+        heapq.heappush(open_set, (0, (sx, sy)))
+        came_from = {}
+        g_score = {(sx, sy): 0}
+
+        directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]
+
+        while open_set:
+            _, current = heapq.heappop(open_set)
+
+            if current == (gx, gy):
+                path = [current]
+                while current in came_from:
+                    current = came_from[current]
+                    path.append(current)
+                path.reverse()
+
+                world_path = []
+                for x, y in path:
+                    wx, wy = grid_to_world(x, y, self.resolution)
+                    world_path.append((wx, wy))
+                return world_path
+
+            for dx, dy in directions:
+                nx, ny = current[0] + dx, current[1] + dy
+
+                if self.is_valid_position(nx, ny, occupancy_grid):
+                    tentative_g = g_score[current] + np.hypot(dx, dy)
+
+                    if (nx, ny) not in g_score or tentative_g < g_score[(nx, ny)]:
+                        g_score[(nx, ny)] = tentative_g
+                        f_score = tentative_g + np.hypot(gx - nx, gy - ny)
+                        heapq.heappush(open_set, (f_score, (nx, ny)))
+                        came_from[(nx, ny)] = current
+
+        return None
+
+
+class SimplifiedFrontierExplorer:
+    def __init__(self, enable_visualization=True):
+        # ç›´æ¥ç”¨å…¨å±€åœ°å›¾å’Œåˆ†è¾¨ç‡
+        self.resolution = MAP_RESOLUTION
+        self.true_map = get_global_map()
+
+        # SLAM map åˆå§‹åŒ–ä¸ºæœªçŸ¥
+        self.slam_map = np.full_like(self.true_map, -1, dtype=np.float32)
 
-        self.viz = MapVisualizer(
-            map_size_pixels=self.map_size_pixels,
-            map_size_meters=self.map_size_meters,
-            title=title,
-            show_trajectory=False
-        )
+        # æœºå™¨äººèµ·ç‚¹
+        start_pos = [START_POSITION['x'], START_POSITION['y']]
+        self.robot = Robot(start_pos[0], start_pos[1], 0)
+
+        # å…¶å®ƒåˆå§‹åŒ–ä¿æŒä¸å˜
+        self.lidar_data = []
+        self.odometry_data = []
+        self.robot_path = []
+        self.timestamp = 0
+        self.exploration_complete = False
+        self.current_target = None
+        self.frontiers = []
+        self.current_scan_points = []
+        self.enable_visualization = enable_visualization
+        self.map_converter = MapConverter(self.resolution)
+        self.lidar_sim = LidarSimulator(range_max=5.0, num_beams=360)
+        self.path_planner = AStarPathPlanner(self.resolution, safety_margin=0.15)
         
-        # å¯è§†åŒ–å…ƒç´ 
-        self.traj_line = None
-        self.path_line = None
-        self.lidar_points = None
-        self.laser_lines = []
-        self.robot_patch = None
-        self.obstacle_points = None
-        self.frontier_points = None  # æ–°å¢ï¼šå‰æ²¿ç‚¹
-        self.current_goal = None     # æ–°å¢ï¼šå½“å‰ç›®æ ‡ç‚¹
-        self.status_text = None      # æ–°å¢ï¼šçŠ¶æ€æ–‡æœ¬
+        # åˆå§‹åŒ–SLAMç³»ç»Ÿ
+        self.slam_system = CarSLAM(map_size_pixels=500, map_size_meters=20)
+        self.slam_map_breezy = None
+        self.slam_pos = None
         
-        # åŠ¨ç”»æ§åˆ¶
-        self.frame_count = 0
-        self.last_update_time = 0
+        # è®°å½•ä¸Šä¸€æ—¶åˆ»çš„ä½ç½®å’Œæ—¶é—´ï¼Œç”¨äºè®¡ç®—å¾®åˆ†
+        self.prev_robot_pos = np.array([self.robot.x, self.robot.y])
+        self.prev_robot_theta = self.robot.theta
+        self.prev_time = 0.0
+        self.dt = 100000.0  # æ—¶é—´æ­¥é•¿ï¼ˆå¾®ç§’ï¼‰
         
-        # è®¾ç½®matplotlibä¸ºäº¤äº’æ¨¡å¼ï¼Œæé«˜åŠ¨ç”»æ€§èƒ½
-        import matplotlib.pyplot as plt
+        if self.enable_visualization:
+            self.setup_visualization()
+
+    def setup_visualization(self):
+        """Setup visualization with three windows"""
+        plt.style.use('dark_background')
         plt.ion()
 
-    def update(self, map_bytes, pose, lidar_scan=None, trajectory=None, nav_path=None, 
-               frontiers=None, current_goal=None, status_info=None):
-        """
-        æ›´æ–°å¯è§†åŒ–æ˜¾ç¤º
-        
-        å‚æ•°ï¼š
-        - map_bytes: SLAMåœ°å›¾æ•°æ®
-        - pose: æœºå™¨äººä½å§¿ [x, y, theta]
-        - lidar_scan: æ¿€å…‰æ‰«ææ•°æ®
-        - trajectory: è½¨è¿¹ç‚¹åˆ—è¡¨
-        - nav_path: å¯¼èˆªè·¯å¾„
-        - frontiers: å‰æ²¿ç‚¹åˆ—è¡¨ [(x1, y1), (x2, y2), ...]
-        - current_goal: å½“å‰ç›®æ ‡ç‚¹ (x, y)
-        - status_info: çŠ¶æ€ä¿¡æ¯å­—å…¸
-        """
-        x, y, theta = pose
-        theta_deg = np.degrees(theta)
-        
-        # å•ä½è½¬æ¢
-        if self.use_mm:
-            x_mm = x * 1000
-            y_mm = y * 1000
-        else:
-            x_mm = x
-            y_mm = y
+        self.fig = plt.figure(figsize=(20, 12))
+        self.fig.patch.set_facecolor('#1e1e1e')
+
+        # Create custom grid layout - 2x3 for three maps + status
+        gs = self.fig.add_gridspec(2, 3, height_ratios=[3, 1], width_ratios=[1, 1, 1],
+                                   hspace=0.3, wspace=0.3)
+
+        # Main map displays - three windows
+        self.ax1 = self.fig.add_subplot(gs[0, 0])  # Ground Truth
+        self.ax2 = self.fig.add_subplot(gs[0, 1])  # SLAM Mapping
+        self.ax3 = self.fig.add_subplot(gs[0, 2])  # BreezySLAM Map
+
+        # Status panel spans all three columns
+        self.ax_status = self.fig.add_subplot(gs[1, :])
+        self.ax_status.axis('off')
+
+        # Set titles with modern styling
+        title_style = {'fontsize': 16, 'fontweight': 'bold', 'color': '#00ff88', 'pad': 20}
+        self.ax1.set_title('ğŸŒ Ground Truth Environment', **title_style)
+        self.ax2.set_title('ğŸ—ºï¸ SLAM Mapping & Exploration', **title_style)
+        self.ax3.set_title('ğŸ¤– BreezySLAM Real-time Map', **title_style)
+
+        # Set background colors
+        for ax in [self.ax1, self.ax2, self.ax3]:
+            ax.set_facecolor('#2a2a2a')
+            ax.grid(True, alpha=0.3, color='#666666', linewidth=0.5)
+            ax.set_xlabel('X Position (m)', color='#cccccc', fontsize=12)
+            ax.set_ylabel('Y Position (m)', color='#cccccc', fontsize=12)
+
+        # Initialize map images with custom colormaps
+        self.true_map_img = self.ax1.imshow(self.true_map, cmap='binary', origin='lower', alpha=0.8)
+
+        # Custom colormap for SLAM map
+        slam_cmap = plt.get_cmap('RdYlGn_r')
+        self.slam_map_img = self.ax2.imshow(self.slam_map, cmap=slam_cmap, origin='lower',
+                                            vmin=-1, vmax=1, alpha=0.9)
+
+        # Initialize BreezySLAM map (black and white)
+        self.breezy_map_img = self.ax3.imshow(np.zeros((500, 500)), cmap='gray', origin='lower',
+                                              vmin=0, vmax=1, alpha=0.9)
+
+        # Robot visualization with enhanced styling
+        robot_color = '#ff4444'
+        robot_radius_grid = self.robot.radius / self.resolution
+        self.robot_true = Circle((0, 0), robot_radius_grid, color=robot_color, alpha=0.9, linewidth=2,
+                                 edgecolor='white', zorder=10)
+        self.robot_slam = Circle((0, 0), robot_radius_grid, color=robot_color, alpha=0.9, linewidth=2,
+                                 edgecolor='white', zorder=10)
+        self.robot_breezy = Circle((0, 0), robot_radius_grid, color=robot_color, alpha=0.9, linewidth=2,
+                                   edgecolor='white', zorder=10)
+
+        self.ax1.add_patch(self.robot_true)
+        self.ax2.add_patch(self.robot_slam)
+        self.ax3.add_patch(self.robot_breezy)
+
+        # Enhanced path visualization
+        self.path_line_true, = self.ax1.plot([], [], color='#00aaff', linewidth=3,
+                                             alpha=0.8, label='Robot Path', zorder=5)
+        self.path_line_slam, = self.ax2.plot([], [], color='#00aaff', linewidth=3,
+                                             alpha=0.8, label='Robot Path', zorder=5)
+        self.path_line_breezy, = self.ax3.plot([], [], color='#00aaff', linewidth=3,
+                                               alpha=0.8, label='Robot Path', zorder=5)
+
+        # Frontier and target visualization (only on SLAM map)
+        self.frontier_points, = self.ax2.plot([], [], 'o', color='#00ff88', markersize=10,
+                                              alpha=0.9, label='Frontier Points', zorder=8)
+
+        self.target_point, = self.ax2.plot([], [], '*', color='#ffff00', markersize=8,
+                                           label='Current Target', zorder=9)
+
+        # Planned path visualization (only on SLAM map)
+        self.planned_path, = self.ax2.plot([], [], '--', color='#ff8800', linewidth=4,
+                                           alpha=0.8, label='Planned Path', zorder=7)
+
+        # LiDAR scan visualization (only on ground truth)
+        self.scan_points, = self.ax1.plot([], [], '.', color='#ffff44', markersize=2,
+                                          alpha=0.8, label='LiDAR Scan', zorder=3)
+
+        # Enhanced legends
+        legend_style = {'fancybox': True, 'framealpha': 0.9, 'facecolor': '#2a2a2a',
+                        'edgecolor': '#666666', 'fontsize': 10}
+        self.ax1.legend(loc='upper right', **legend_style)
+        self.ax2.legend(loc='upper right', **legend_style)
+        self.ax3.legend(loc='upper right', **legend_style)
+
+        # Set axis limits and styling
+        for ax in [self.ax1, self.ax2]:
+            ax.set_xlim(0, self.true_map.shape[1])
+            ax.set_ylim(0, self.true_map.shape[0])
+            ax.tick_params(colors='#cccccc', labelsize=10)
+        
+        # Set axis limits for BreezySLAM map
+        self.ax3.set_xlim(0, 500)
+        self.ax3.set_ylim(0, 500)
+        self.ax3.tick_params(colors='#cccccc', labelsize=10)
+
+        # Initialize arrow placeholders
+        self.robot_arrow_true = None
+        self.robot_arrow_slam = None
+        self.robot_arrow_breezy = None
+
+        # Status display setup
+        self.setup_status_display()
+
+    def setup_status_display(self):
+        """Setup enhanced status display panel"""
+        # Create status text areas
+        self.status_texts = {}
+
+        # Main status line
+        self.main_status = self.ax_status.text(0.5, 0.8, '', ha='center', va='center',
+                                               fontsize=18, fontweight='bold', color='#00ff88',
+                                               transform=self.ax_status.transAxes)
+
+        # Statistics grid
+        stats_x_positions = [0.1, 0.3, 0.5, 0.7, 0.9]
+        stats_labels = ['Steps', 'Position', 'Frontiers', 'Unknown', 'Time']
+        self.stats_labels = []
+        self.stats_values = []
+
+        for i, (x_pos, label) in enumerate(zip(stats_x_positions, stats_labels)):
+            # Label
+            label_text = self.ax_status.text(x_pos, 0.5, label, ha='center', va='top',
+                                             fontsize=12, fontweight='bold', color='#cccccc',
+                                             transform=self.ax_status.transAxes)
+            self.stats_labels.append(label_text)
+
+            # Value
+            value_text = self.ax_status.text(x_pos, 0.2, '---', ha='center', va='top',
+                                             fontsize=14, fontweight='bold', color='#ffffff',
+                                             transform=self.ax_status.transAxes)
+            self.stats_values.append(value_text)
+
+        # Progress bar background
+        self.progress_bg = Rectangle((0.05, 0.05), 0.9, 0.1, transform=self.ax_status.transAxes,
+                                     facecolor='#444444', edgecolor='#666666', linewidth=1)
+        self.ax_status.add_patch(self.progress_bg)
+
+        # Progress bar
+        self.progress_bar = Rectangle((0.05, 0.05), 0.0, 0.1, transform=self.ax_status.transAxes,
+                                      facecolor='#00ff88', alpha=0.8)
+        self.ax_status.add_patch(self.progress_bar)
+
+    def update_slam_map(self, lidar_scan):
+        """Update SLAM map with lidar data"""
+        self.current_scan_points = []
+
+        for i, (angle, range_val) in enumerate(zip(lidar_scan.angles, lidar_scan.ranges)):
+            global_angle = self.robot.theta + angle
+            end_x = self.robot.x + range_val * math.cos(global_angle)
+            end_y = self.robot.y + range_val * math.sin(global_angle)
+
+            self.current_scan_points.extend([end_x / self.resolution, end_y / self.resolution])
+            self._update_ray_fast(self.robot.x, self.robot.y, end_x, end_y)
+
+            if range_val < self.lidar_sim.range_max - 0.1:
+                gx = int(end_x / self.resolution)
+                gy = int(end_y / self.resolution)
+                if (0 <= gx < self.slam_map.shape[1] and
+                        0 <= gy < self.slam_map.shape[0]):
+                    self.slam_map[gy, gx] = 1.0
+
+    def _update_ray_fast(self, start_x, start_y, end_x, end_y):
+        """Fast ray update using simplified line drawing"""
+        distance = np.hypot(end_x - start_x, end_y - start_y)
+        num_samples = int(distance / self.resolution) + 1
+
+        # ç¡®ä¿ num_samples è‡³å°‘ä¸º1
+        if num_samples < 1:
+            num_samples = 1
+
+        for i in range(num_samples):
+            ratio = i / max(num_samples - 1, 1)
+            x = start_x + ratio * (end_x - start_x)
+            y = start_y + ratio * (end_y - start_y)
+
+            gx = int(x / self.resolution)
+            gy = int(y / self.resolution)
+
+            if (0 <= gx < self.slam_map.shape[1] and
+                    0 <= gy < self.slam_map.shape[0] and
+                    self.slam_map[gy, gx] == -1):
+                self.slam_map[gy, gx] = 0.0
+
+    def get_next_frontier(self):
+        """Get next frontier target"""
+        self.frontiers = detect_frontiers_optimized(
+            self.slam_map,
+            map_resolution=self.resolution
+        )
+
+        if not self.frontiers:
+            return None
+
+        robot_pos = (self.robot.x, self.robot.y)
+        return select_best_frontier(self.frontiers, robot_pos, self.slam_map,
+                                    self.resolution, self.path_planner)
+
+    def find_nearest_unknown_area(self):
+        """Find the nearest unknown area when no frontiers are available"""
+        unknown_y, unknown_x = np.where(self.slam_map == -1)
+
+        if len(unknown_x) == 0:
+            return None
+
+        robot_x_grid = self.robot.x / self.resolution
+        robot_y_grid = self.robot.y / self.resolution
+
+        distances = np.sqrt((unknown_x - robot_x_grid) ** 2 + (unknown_y - robot_y_grid) ** 2)
+
+        nearest_idx = np.argmin(distances)
+        nearest_x = unknown_x[nearest_idx]
+        nearest_y = unknown_y[nearest_idx]
+
+        world_x = nearest_x * self.resolution
+        world_y = nearest_y * self.resolution
+
+        return (world_x, world_y)
+
+    def navigate_to_target(self, target):
+        """Navigate robot to target using separated rotation and translation"""
+        if target is None:
+            return False
+
+        # è®¡ç®—åˆ°ç›®æ ‡çš„æ–¹å‘å’Œè·ç¦»
+        dx = target[0] - self.robot.x
+        dy = target[1] - self.robot.y
+        distance_to_target = np.hypot(dx, dy)
+        
+        # å¦‚æœå·²ç»è¶³å¤Ÿæ¥è¿‘ç›®æ ‡ï¼Œè¿”å›æˆåŠŸ
+        if distance_to_target < self.resolution * 2:
+            return True
+        
+        # è®¡ç®—ç›®æ ‡è§’åº¦
+        target_angle = math.atan2(dy, dx)
+        
+        # è®¡ç®—å½“å‰æœå‘ä¸ç›®æ ‡æ–¹å‘çš„å¤¹è§’
+        angle_diff = target_angle - self.robot.theta
+        # å½’ä¸€åŒ–è§’åº¦åˆ°[-Ï€, Ï€]
+        while angle_diff > math.pi:
+            angle_diff -= 2 * math.pi
+        while angle_diff < -math.pi:
+            angle_diff += 2 * math.pi
+        
+        # åˆ¤æ–­æ˜¯å¦éœ€è¦æ—‹è½¬æˆ–å‰è¿›
+        angle_threshold = 0.1  # è§’åº¦é˜ˆå€¼ï¼ˆå¼§åº¦ï¼‰
+        min_distance_threshold = 0.05  # æœ€å°å‰è¿›è·ç¦»é˜ˆå€¼ï¼ˆç±³ï¼‰
+        
+        if abs(angle_diff) > angle_threshold:
+            # åªæ—‹è½¬ï¼Œä¸å‰è¿›
+            rotation_step = 0.1  # æ¯æ¬¡æ—‹è½¬çš„æ­¥é•¿ï¼ˆå¼§åº¦ï¼‰
+            if angle_diff > 0:
+                self.robot.theta += rotation_step
+            else:
+                self.robot.theta -= rotation_step
             
-        # æ›´æ–°SLAMåœ°å›¾
-        self.viz.display(x_mm, y_mm, theta_deg, map_bytes)
-
-        # æ¸…ç†æ—§çš„æ¿€å…‰å°„çº¿
-        for line in self.laser_lines:
-            try:
-                line.remove()
-            except Exception:
-                pass
-        self.laser_lines = []
-
-        # ç»˜åˆ¶æ¿€å…‰å°„çº¿
-        if lidar_scan is not None:
-            scan_angles = np.linspace(0, 2*np.pi, len(lidar_scan), endpoint=False)
-            scan_dist = np.array(lidar_scan)
-            if not self.use_mm:
-                scan_dist = scan_dist / 1000.0  # è½¬ç±³
-            valid = (scan_dist > 0) & (scan_dist < (4000 if self.use_mm else 4.0))
-            scan_angles = scan_angles[valid]
-            scan_dist = scan_dist[valid]
+            # å½’ä¸€åŒ–è§’åº¦
+            self.robot.theta = self.robot.normalize_angle(self.robot.theta)
+            
+        elif distance_to_target > min_distance_threshold:
+            # åªå‰è¿›ï¼Œä¸æ—‹è½¬
+            # è®¡ç®—å‰è¿›æ­¥é•¿
+            forward_step = min(0.1, distance_to_target)  # æ¯æ¬¡å‰è¿›çš„æ­¥é•¿ï¼ˆç±³ï¼‰
+            
+            # è®¡ç®—æ–°ä½ç½®
+            new_x = self.robot.x + forward_step * math.cos(self.robot.theta)
+            new_y = self.robot.y + forward_step * math.sin(self.robot.theta)
             
-            for r, a in zip(scan_dist, scan_angles):
-                if self.use_mm:
-                    end_x = x_mm + r * np.cos(theta + a)
-                    end_y = y_mm + r * np.sin(theta + a)
-                else:
-                    end_x = x + r * np.cos(theta + a)
-                    end_y = y + r * np.sin(theta + a)
-                # ç”»å°„çº¿ - ä½¿ç”¨çº¢è‰²ï¼Œæ›´é†’ç›®
-                line, = self.viz.ax.plot([x_mm, end_x], [y_mm, end_y], 
-                                       color='red', linewidth=0.5, alpha=0.6, zorder=2)
-                self.laser_lines.append(line)
+            # æ£€æŸ¥æ–°ä½ç½®æ˜¯å¦å®‰å…¨
+            if self.robot.is_position_safe(new_x, new_y, self.slam_map, self.resolution):
+                self.robot.x = new_x
+                self.robot.y = new_y
+            else:
+                # å¦‚æœå‰è¿›ä¸å®‰å…¨ï¼Œå°è¯•æ—‹è½¬
+                rotation_step = 0.1
+                self.robot.theta += rotation_step
+                self.robot.theta = self.robot.normalize_angle(self.robot.theta)
+        
+        return False
+
+    def update_visualization(self):
+        """Update visualization elements"""
+        if not self.enable_visualization:
+            return
+
+        # Update robot positions
+        robot_x_grid = self.robot.x / self.resolution
+        robot_y_grid = self.robot.y / self.resolution
 
-        # æ›´æ–°è½¨è¿¹
-        if self.traj_line:
-            self.traj_line.remove()
-            self.traj_line = None
-        if trajectory and len(trajectory) > 1:
-            if self.use_mm:
-                traj_x = [p[0]*1000 for p in trajectory]
-                traj_y = [p[1]*1000 for p in trajectory]
-            else:
-                traj_x = [p[0] for p in trajectory]
-                traj_y = [p[1] for p in trajectory]
-            self.traj_line, = self.viz.ax.plot(traj_x, traj_y, 'blue', 
-                                             linewidth=1.5, alpha=0.8, zorder=4, 
-                                             label='Robot Trajectory')
+        self.robot_true.center = (robot_x_grid, robot_y_grid)
+        self.robot_slam.center = (robot_x_grid, robot_y_grid)
+
+        # Update robot direction arrows
+        self._update_robot_arrows(robot_x_grid, robot_y_grid)
+
+        # Update paths
+        if len(self.robot_path) > 1:
+            path_x = [p[0] / self.resolution for p in self.robot_path]
+            path_y = [p[1] / self.resolution for p in self.robot_path]
+
+            self.path_line_true.set_data(path_x, path_y)
+            self.path_line_slam.set_data(path_x, path_y)
+
+        # Update SLAM map
+        slam_display = self.slam_map.copy()
+        slam_display[slam_display == -1] = 0.5  # Unknown as neutral
+        self.slam_map_img.set_array(slam_display)
+        
+        # Update BreezySLAM map and robot position
+        if self.slam_map_breezy is not None:
+            self.breezy_map_img.set_array(self.slam_map_breezy)
+            
+            # Update BreezySLAM robot position
+            if self.slam_pos is not None:
+                # å°†SLAMä½ç½®è½¬æ¢ä¸ºåƒç´ åæ ‡
+                slam_x_pixels = int(self.slam_pos[0] * self.slam_map_breezy.shape[1] / 20)
+                slam_y_pixels = int(self.slam_pos[1] * self.slam_map_breezy.shape[0] / 20)
+                self.robot_breezy.center = (slam_x_pixels, slam_y_pixels)
+                
+                # Update BreezySLAM path
+                if len(self.robot_path) > 1:
+                    # å°†è·¯å¾„è½¬æ¢ä¸ºBreezySLAMåæ ‡ç³»
+                    breezy_path_x = []
+                    breezy_path_y = []
+                    for p in self.robot_path:
+                        px_pixels = int(p[0] * self.slam_map_breezy.shape[1] / 20)
+                        py_pixels = int(p[1] * self.slam_map_breezy.shape[0] / 20)
+                        breezy_path_x.append(px_pixels)
+                        breezy_path_y.append(py_pixels)
+                    self.path_line_breezy.set_data(breezy_path_x, breezy_path_y)
+
+        # Update frontiers
+        self._update_frontiers()
+
+        # Update target
+        self._update_target()
+
+        # Update planned path
+        self._update_planned_path()
+
+        # Update LiDAR scan
+        self._update_lidar_scan()
+
+        # Update status display
+        self._update_status_display()
+
+        # Refresh display
+        self.fig.canvas.draw()
+        self.fig.canvas.flush_events()
+
+    def _update_robot_arrows(self, robot_x_grid, robot_y_grid):
+        """Update robot direction arrows"""
+        # Remove old arrows
+        if self.robot_arrow_true:
+            self.robot_arrow_true.remove()
+        if self.robot_arrow_slam:
+            self.robot_arrow_slam.remove()
+        if self.robot_arrow_breezy:
+            self.robot_arrow_breezy.remove()
+
+        # Add new arrows
+        arrow_length = self.robot.radius / self.resolution * 2  # ç®­å¤´é•¿åº¦ä¸ºå°è½¦åŠå¾„çš„2å€ï¼ˆå•ä½ï¼šæ ¼ï¼‰
+        dx = arrow_length * math.cos(self.robot.theta)
+        dy = arrow_length * math.sin(self.robot.theta)
+
+        # è®©ç®­å¤´å¤´éƒ¨å®½åº¦å’Œé•¿åº¦ä¹Ÿéšç®­å¤´é•¿åº¦ç¼©æ”¾
+        head_width = arrow_length * 0.5   # ä½ å¯ä»¥è°ƒèŠ‚è¿™ä¸ªç³»æ•°
+        head_length = arrow_length * 0.4  # ä½ å¯ä»¥è°ƒèŠ‚è¿™ä¸ªç³»æ•°
+
+        arrow_style = dict(
+            head_width=head_width,
+            head_length=head_length,
+            fc='#ffffff',
+            ec='#ffffff',
+            linewidth=2.0,
+            alpha=0.9,
+            zorder=15
+        )
+
+        self.robot_arrow_true = FancyArrow(robot_x_grid, robot_y_grid, dx, dy, **arrow_style)
+        self.robot_arrow_slam = FancyArrow(robot_x_grid, robot_y_grid, dx, dy, **arrow_style)
+        
+        # Add BreezySLAM arrow if position is available
+        if self.slam_pos is not None and self.slam_map_breezy is not None:
+            slam_x_pixels = int(self.slam_pos[0] * self.slam_map_breezy.shape[1] / 20)
+            slam_y_pixels = int(self.slam_pos[1] * self.slam_map_breezy.shape[0] / 20)
+            # åœ¨BreezySLAMåæ ‡ç³»ä¸­çš„ç®­å¤´é•¿åº¦
+            breezy_arrow_length = 20  # åƒç´ å•ä½
+            breezy_dx = breezy_arrow_length * math.cos(self.slam_pos[2])
+            breezy_dy = breezy_arrow_length * math.sin(self.slam_pos[2])
+            
+            breezy_arrow_style = dict(
+                head_width=10,
+                head_length=8,
+                fc='#ffffff',
+                ec='#ffffff',
+                linewidth=2.0,
+                alpha=0.9,
+                zorder=15
+            )
+            self.robot_arrow_breezy = FancyArrow(slam_x_pixels, slam_y_pixels, breezy_dx, breezy_dy, **breezy_arrow_style)
+            self.ax3.add_patch(self.robot_arrow_breezy)
+
+        self.ax1.add_patch(self.robot_arrow_true)
+        self.ax2.add_patch(self.robot_arrow_slam)
+
+    def _update_frontiers(self):
+        """Update frontier visualization"""
+        if self.frontiers:
+            frontier_x = [f[0] / self.resolution for f in self.frontiers]
+            frontier_y = [f[1] / self.resolution for f in self.frontiers]
+            self.frontier_points.set_data(frontier_x, frontier_y)
+        else:
+            self.frontier_points.set_data([], [])
 
-        # æ›´æ–°å¯¼èˆªè·¯å¾„
-        if self.path_line:
-            self.path_line.remove()
-            self.path_line = None
-        if nav_path and len(nav_path) > 1:
-            if self.use_mm:
-                path_x = [p[0]*1000 for p in nav_path]
-                path_y = [p[1]*1000 for p in nav_path]
-            else:
-                path_x = [p[0] for p in nav_path]
-                path_y = [p[1] for p in nav_path]
-            self.path_line, = self.viz.ax.plot(path_x, path_y, 'green', 
-                                             linewidth=2, alpha=0.7, zorder=3, 
-                                             linestyle='--', label='Navigation Path')
+    def _update_target(self):
+        """Update target visualization"""
+        if self.current_target:
+            target_x = self.current_target[0] / self.resolution
+            target_y = self.current_target[1] / self.resolution
+            self.target_point.set_data([target_x], [target_y])
+        else:
+            self.target_point.set_data([], [])
 
-        # æ›´æ–°å‰æ²¿ç‚¹
-        if self.frontier_points:
-            self.frontier_points.remove()
-            self.frontier_points = None
-        if frontiers and len(frontiers) > 0:
-            if self.use_mm:
-                frontier_x = [f[0]*1000 for f in frontiers]
-                frontier_y = [f[1]*1000 for f in frontiers]
-            else:
-                frontier_x = [f[0] for f in frontiers]
-                frontier_y = [f[1] for f in frontiers]
-            self.frontier_points = self.viz.ax.scatter(frontier_x, frontier_y, 
-                                                     c='yellow', s=30, alpha=0.8, 
-                                                     edgecolors='orange', linewidth=1,
-                                                     label='Frontiers', zorder=5)
+    def _update_planned_path(self):
+        """Update planned path visualization"""
+        # ç”±äºæˆ‘ä»¬ç°åœ¨ä½¿ç”¨åˆ†ç¦»çš„æ—‹è½¬å’Œå‰è¿›ï¼Œä¸å†æ˜¾ç¤ºè§„åˆ’è·¯å¾„
+        self.planned_path.set_data([], [])
+
+    def _update_lidar_scan(self):
+        """Update LiDAR scan visualization"""
+        if len(self.current_scan_points) > 1:
+            scan_x = self.current_scan_points[::2]
+            scan_y = self.current_scan_points[1::2]
+            self.scan_points.set_data(scan_x, scan_y)
+        else:
+            self.scan_points.set_data([], [])
 
-        # æ›´æ–°å½“å‰ç›®æ ‡ç‚¹
-        if self.current_goal:
-            self.current_goal.remove()
-            self.current_goal = None
-        if current_goal:
-            if self.use_mm:
-                goal_x = current_goal[0] * 1000
-                goal_y = current_goal[1] * 1000
-            else:
-                goal_x = current_goal[0]
-                goal_y = current_goal[1]
-            self.current_goal = self.viz.ax.scatter(goal_x, goal_y, 
-                                                  c='magenta', s=100, alpha=0.9,
-                                                  edgecolors='purple', linewidth=2,
-                                                  marker='*', label='Current Goal', zorder=6)
-
-        # æ›´æ–°æœºå™¨äººä¸‰è§’å½¢
-        if self.robot_patch:
-            self.robot_patch.remove()
-            self.robot_patch = None
-        # æœºå™¨äººä¸‰è§’å½¢å‚æ•°
-        tri_len = 200 if self.use_mm else 0.2  # 20cm
-        tri_wid = 100 if self.use_mm else 0.1  # 10cm
-        # æœºå™¨äººæœå‘ä¸‰è§’å½¢é¡¶ç‚¹
-        tip = (x_mm + tri_len * np.cos(theta), y_mm + tri_len * np.sin(theta))
-        left = (x_mm + tri_wid * np.cos(theta + 2.5), y_mm + tri_wid * np.sin(theta + 2.5))
-        right = (x_mm + tri_wid * np.cos(theta - 2.5), y_mm + tri_wid * np.sin(theta - 2.5))
-        triangle = np.array([tip, left, right])
-        self.robot_patch = mpatches.Polygon(triangle, color='red', zorder=10)
-        self.viz.ax.add_patch(self.robot_patch)
+    def _update_status_display(self):
+        """Update status display with current information"""
+        # Main status
+        num_frontiers = len(self.frontiers) if self.frontiers else 0
+        unknown_ratio = np.sum(self.slam_map == -1) / self.slam_map.size
+
+        if self.exploration_complete:
+            status = "ğŸ‰ EXPLORATION COMPLETE!"
+            self.main_status.set_color('#00ff88')
+        elif self.current_target:
+            status = "ğŸ¯ ACTIVELY EXPLORING"
+            self.main_status.set_color('#ffff00')
+        else:
+            status = "ğŸ” SEARCHING FOR TARGETS"
+            self.main_status.set_color('#ff8800')
 
-        # æ›´æ–°çŠ¶æ€æ–‡æœ¬
-        if self.status_text:
-            self.status_text.remove()
-            self.status_text = None
-        if status_info:
-            status_str = f"Frame: {self.frame_count}\n"
-            for key, value in status_info.items():
-                status_str += f"{key}: {value}\n"
-            self.status_text = self.viz.ax.text(0.02, 0.98, status_str,
-                                              transform=self.viz.ax.transAxes,
-                                              verticalalignment='top',
-                                              bbox=dict(boxstyle='round', facecolor='white', alpha=0.8),
-                                              fontsize=8, zorder=20)
+        self.main_status.set_text(status)
 
-        # æ›´æ–°å›¾ä¾‹
-        if not self.viz.ax.get_legend():
-            self.viz.ax.legend(loc='upper right', fontsize=8)
+        # Update statistics
+        stats_data = [
+            len(self.robot_path),
+            f"({self.robot.x:.1f}, {self.robot.y:.1f})",
+            num_frontiers,
+            f"{unknown_ratio:.1%}",
+            f"{self.timestamp:.1f}s"
+        ]
 
-        # æ›´æ–°è®¡æ•°
-        self.frame_count += 1
+        for i, (value_text, data) in enumerate(zip(self.stats_values, stats_data)):
+            value_text.set_text(str(data))
 
-    def add_obstacle_points(self, obstacle_points):
-        """
-        æ·»åŠ éšœç¢ç‰©ç‚¹å¯è§†åŒ–
-        
-        å‚æ•°ï¼š
-        - obstacle_points: [(x1, y1), (x2, y2), ...] éšœç¢ç‰©ç‚¹åˆ—è¡¨
-        """
-        if self.obstacle_points:
-            self.obstacle_points.remove()
-            self.obstacle_points = None
-        
-        if obstacle_points and len(obstacle_points) > 0:
-            if self.use_mm:
-                obs_x = [p[0]*1000 for p in obstacle_points]
-                obs_y = [p[1]*1000 for p in obstacle_points]
-            else:
-                obs_x = [p[0] for p in obstacle_points]
-                obs_y = [p[1] for p in obstacle_points]
-            
-            self.obstacle_points = self.viz.ax.scatter(obs_x, obs_y, 
-                                                     c='black', s=20, alpha=0.8,
-                                                     label='Obstacles', zorder=1)
+        # Update progress bar
+        progress = 1.0 - unknown_ratio
+        self.progress_bar.set_width(0.9 * progress)
+
+        # Color code progress
+        if progress > 0.8:
+            self.progress_bar.set_facecolor('#00ff88')
+        elif progress > 0.5:
+            self.progress_bar.set_facecolor('#ffff00')
+        else:
+            self.progress_bar.set_facecolor('#ff8800')
+
+    def explore_step(self, dt=0.1):
+        """Single exploration step"""
+        self.robot_path.append([self.robot.x, self.robot.y])
 
-    def save_map(self, filename='roboviz_slam_map.png'):
-        """
-        ä¿å­˜å½“å‰åœ°å›¾ä¸ºå›¾ç‰‡
-        """
-        try:
-            if hasattr(self.viz, 'fig'):
-                self.viz.fig.savefig(filename, dpi=150, bbox_inches='tight')  # type: ignore
-            elif hasattr(self.viz, 'figure'):
-                self.viz.figure.savefig(filename, dpi=150, bbox_inches='tight')  # type: ignore
-            elif hasattr(self.viz, 'ax'):
-                self.viz.ax.figure.savefig(filename, dpi=150, bbox_inches='tight')  # type: ignore
-            else:
-                import matplotlib.pyplot as plt
-                plt.savefig(filename, dpi=150, bbox_inches='tight')
-            print(f"âœ… åœ°å›¾å·²ä¿å­˜: {filename}")
-        except Exception as e:
-            print(f"âŒ ä¿å­˜åœ°å›¾å¤±è´¥: {e}")
-
-    def close(self):
-        """
-        å…³é—­å¯è§†åŒ–çª—å£
-        """
-        try:
-            if hasattr(self.viz, 'close'):
-                self.viz.close()
-            else:
-                import matplotlib.pyplot as plt
-                plt.close('all')
-        except Exception as e:
-            print(f"å…³é—­å¯è§†åŒ–çª—å£æ—¶å‡ºé”™: {e}")
+        robot_pos = (self.robot.x, self.robot.y, self.robot.theta)
+        lidar_scan = self.lidar_sim.scan(robot_pos, self.true_map, self.resolution)
+        lidar_scan.timestamp = self.timestamp
+        self.lidar_data.append(lidar_scan)
+
+        odom = Odometry(self.robot.x, self.robot.y, self.robot.theta, self.timestamp)
+        self.odometry_data.append(odom)
+
+        self.update_slam_map(lidar_scan)
+        
+        # æ›´æ–°BreezySLAMï¼ˆå¦‚æœå¯ç”¨ä¸”ä¸æ˜¯ç¬¬ä¸€æ­¥ï¼‰
+        if self.slam_system.available and len(self.robot_path) > 1:
+            # è®¡ç®—é‡Œç¨‹è®¡æ•°æ®ï¼ˆä½å§¿å˜åŒ–ï¼‰
+            dx = self.robot.x - self.prev_robot_pos[0]
+            dy = self.robot.y - self.prev_robot_pos[1]
+            dtheta = self.robot.theta - self.prev_robot_theta
+            
+            # å½’ä¸€åŒ–è§’åº¦å·®
+            while dtheta > np.pi:
+                dtheta -= 2 * np.pi
+            while dtheta < -np.pi:
+                dtheta += 2 * np.pi
+            
+            # è½¬æ¢ä¸ºæ¯«ç±³å’Œåº¦
+            pose_change = (int(dx * 1000), int(np.degrees(dtheta)), int(dy * 1000))
+            
+            # æ›´æ–°SLAM
+            self.slam_pos = self.slam_system.update_position(lidar_scan.ranges, pose_change)
+            self.slam_map_breezy = self.slam_system.get_map_array()
+        
+        # æ›´æ–°ä¸Šä¸€æ—¶åˆ»çš„æ•°æ®
+        self.prev_robot_pos = np.array([self.robot.x, self.robot.y])
+        self.prev_robot_theta = self.robot.theta
+        self.prev_time = self.timestamp
+
+        if self.current_target is None:
+            self.current_target = self.get_next_frontier()
+
+        if self.current_target:
+            reached = self.navigate_to_target(self.current_target)
+            if reached:
+                self.current_target = None
+        else:
+            self.current_target = self.get_next_frontier()
+            if self.current_target is None:
+                self.current_target = self.find_nearest_unknown_area()
+                if self.current_target is None:
+                    self.exploration_complete = True
+                else:
+                    unknown_ratio = np.sum(self.slam_map == -1) / self.slam_map.size
+                    print(f"ğŸ” No frontiers found, exploring nearest unknown area: {self.current_target}, "
+                          f"Unknown: {unknown_ratio:.1%}")
+
+        self.timestamp += dt
 
-    def show(self):
-        """
-        æ˜¾ç¤ºå¯è§†åŒ–çª—å£
-        """
+        if self.enable_visualization:
+            self.update_visualization()
+
+        return not self.exploration_complete
+
+    def run_exploration(self, max_steps=1000, delay=0.05):
+        """Run exploration with enhanced visualization"""
+        print("ğŸš€ Starting Simplified Frontier Exploration...")
+        print("ğŸ’¡ Press Ctrl+C to stop early")
+
+        step = 0
+        start_time = time.time()
+
         try:
-            if hasattr(self.viz, 'show'):
-                self.viz.show()
-            else:
-                import matplotlib.pyplot as plt
-                plt.show()
-        except Exception as e:
-            print(f"æ˜¾ç¤ºå¯è§†åŒ–çª—å£æ—¶å‡ºé”™: {e}")
+            while step < max_steps and self.explore_step():
+                step += 1
+
+                if self.enable_visualization and delay > 0:
+                    time.sleep(delay)
+
+                if step % 50 == 0:
+                    unknown_ratio = np.sum(self.slam_map == -1) / self.slam_map.size
+                    elapsed_time = time.time() - start_time
+                    print(f"ğŸ“Š Step {step}: Position ({self.robot.x:.2f}, {self.robot.y:.2f}), "
+                          f"Unknown: {unknown_ratio:.1%}, Time: {elapsed_time:.1f}s")
+
+        except KeyboardInterrupt:
+            print("â¹ï¸  Exploration stopped by user")
+
+        elapsed_time = time.time() - start_time
+        unknown_ratio = np.sum(self.slam_map == -1) / self.slam_map.size
+
+        print(f"âœ… Exploration completed in {step} steps, {elapsed_time:.1f} seconds")
+        print(f"ğŸ“ˆ Final unknown area ratio: {unknown_ratio:.1%}")
+
+        if self.enable_visualization:
+            plt.ioff()
+            self.update_visualization()
+            print("ğŸ–¼ï¸  Visualization window will remain open")
+            plt.show()
 
-    def get_frame_rate(self):
-        """
-        è·å–å½“å‰å¸§ç‡
-        """
-        import time
-        current_time = time.time()
-        if self.last_update_time > 0:
-            fps = 1.0 / (current_time - self.last_update_time)
-        else:
-            fps = 0
-        self.last_update_time = current_time
-        return fps
+        return self.get_exploration_data()
 
+    def run_fast_exploration(self, max_steps=1000):
+        """Run exploration without visualization for maximum speed"""
+        print("âš¡ Starting Fast Exploration (No Visualization)...")
 
-def test_roboviz_viewer():
-    """
-    æµ‹è¯•RoboViz SLAMå¯è§†åŒ–å™¨
-    """
-    import time
-    
-    # åˆ›å»ºå¯è§†åŒ–å™¨
-    viewer = RoboVizSLAMViewer(title='Test SLAM Viewer', use_mm=False)
-    
-    # æ¨¡æ‹Ÿæ•°æ®
-    map_bytes = bytearray(MAP_SIZE * MAP_SIZE)
-    pose = [MAP_SIZE_M/2, MAP_SIZE_M/2, 0.0]  # åœ°å›¾ä¸­å¿ƒ
-    
-    # æ¨¡æ‹Ÿæ¿€å…‰æ‰«ææ•°æ®
-    lidar_scan = [1000 + i * 50 for i in range(360)]
-    
-    # æ¨¡æ‹Ÿè½¨è¿¹
-    trajectory = []
-    for i in range(10):
-        x = MAP_SIZE_M/2 + i * 0.3
-        y = MAP_SIZE_M/2 + i * 0.1
-        theta = i * 0.1
-        trajectory.append([x, y])
-    
-    # æ¨¡æ‹Ÿå‰æ²¿ç‚¹
-    frontiers = [[1.0, 1.0], [2.0, 2.0], [3.0, 1.5]]
-    
-    # æ¨¡æ‹Ÿç›®æ ‡ç‚¹
-    current_goal = [MAP_SIZE_M-1, MAP_SIZE_M-1]
-    
-    # æ›´æ–°å¯è§†åŒ–
-    viewer.update(map_bytes, pose, lidar_scan, trajectory, None, frontiers, current_goal)
-    
-    print("âœ… RoboViz SLAMå¯è§†åŒ–å™¨æµ‹è¯•å®Œæˆ")
-    print(f"åœ°å›¾å°ºå¯¸: {MAP_SIZE}x{MAP_SIZE} åƒç´ ")
-    print(f"åœ°å›¾ç‰©ç†å°ºå¯¸: {MAP_SIZE_M}x{MAP_SIZE_M} ç±³")
-    print(f"åˆ†è¾¨ç‡: {MAP_RESOLUTION} ç±³/åƒç´ ")
-    
-    # ä¿å­˜æµ‹è¯•å›¾ç‰‡
-    viewer.save_map('test_slam_map.png')
-    
-    return viewer
+        step = 0
+        start_time = time.time()
+
+        try:
+            while step < max_steps and self.explore_step():
+                step += 1
+
+                if step % 100 == 0:
+                    unknown_ratio = np.sum(self.slam_map == -1) / self.slam_map.size
+                    elapsed_time = time.time() - start_time
+                    print(f"ğŸ“Š Step {step}: Position ({self.robot.x:.2f}, {self.robot.y:.2f}), "
+                          f"Unknown: {unknown_ratio:.1%}, Time: {elapsed_time:.1f}s")
+
+        except KeyboardInterrupt:
+            print("â¹ï¸  Exploration stopped by user")
+
+        elapsed_time = time.time() - start_time
+        unknown_ratio = np.sum(self.slam_map == -1) / self.slam_map.size
+
+        print(f"âœ… Fast exploration completed in {step} steps, {elapsed_time:.1f} seconds")
+        print(f"ğŸ“ˆ Final unknown area ratio: {unknown_ratio:.1%}")
+
+        return self.get_exploration_data()
+
+    def get_exploration_data(self):
+        """Get exploration data in JSON format"""
+        exploration_data = {
+            "metadata": {
+                "total_steps": len(self.lidar_data),
+                "total_time": self.timestamp,
+                "map_resolution": self.resolution,
+                "final_unknown_ratio": float(np.sum(self.slam_map == -1) / self.slam_map.size)
+            },
+            "lidar_scans": [],
+            "odometry": [],
+            "final_map": self.slam_map.tolist(),
+            "robot_path": self.robot_path
+        }
+
+        for scan in self.lidar_data:
+            exploration_data["lidar_scans"].append({
+                "ranges": scan.ranges,
+                "angles": scan.angles,
+                "timestamp": scan.timestamp
+            })
+
+        for odo in self.odometry_data:
+            exploration_data["odometry"].append({
+                "x": odo.x,
+                "y": odo.y,
+                "theta": odo.theta,
+                "timestamp": odo.timestamp
+            })
+
+        return exploration_data
 
 
+# Example usage
 if __name__ == "__main__":
-    # è¿è¡Œæµ‹è¯•
-    viewer = test_roboviz_viewer()
-    viewer.show() 
\ No newline at end of file
+    print("ğŸ¨ === Simplified Frontier Exploration with Dual Display ===")
+    explorer = SimplifiedFrontierExplorer(enable_visualization=True)
+    exploration_data = explorer.run_exploration(max_steps=500, delay=0.02)
+    with open('simplified_exploration_data.json', 'w', encoding='utf-8') as f:
+        json.dump(exploration_data, f, indent=2, ensure_ascii=False)
+    print("ğŸ’¾ Exploration data saved to 'simplified_exploration_data.json'")
+    print(f"ğŸ“Š Collected {len(exploration_data['lidar_scans'])} LiDAR scans")
+    print(f"ğŸ“Š Collected {len(exploration_data['odometry'])} odometry readings")
Index: config/map.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nfrom skimage.draw import line\r\nfrom config.settings import MAP_SIZE, MAP_SIZE_M, MAP_RESOLUTION\r\n\r\n# åœ°å›¾å‚æ•°\r\nMAP_SIZE = 50\r\nMAP_SIZE_M = 15.0\r\nRESOLUTION = MAP_SIZE_M / MAP_SIZE\r\n\r\n# è€å¸ˆç»™çš„éšœç¢ç‰©çº¿æ®µ\r\nSEGMENTS = [\r\n   {\r\n    \"start\": [0, 0],\r\n    \"end\": [2, 0]\r\n   },\r\n   {\r\n    \"start\": [2, 0],\r\n    \"end\": [2, 2]\r\n   },\r\n   {\r\n    \"start\": [0, 0],\r\n    \"end\": [0, 15]\r\n   },\r\n   {\r\n    \"start\": [0, 11],\r\n    \"end\": [2, 11]\r\n   },\r\n   {\r\n    \"start\": [2, 11],\r\n    \"end\": [2, 6]\r\n   },\r\n   {\r\n    \"start\": [2, 6],\r\n    \"end\": [4, 6]\r\n   },\r\n   {\r\n    \"start\": [0, 15],\r\n    \"end\": [11, 15]\r\n   },\r\n   {\r\n    \"start\": [2, 15],\r\n    \"end\": [2, 13]\r\n   },\r\n   {\r\n    \"start\": [2, 13],\r\n    \"end\": [9, 13]\r\n   },\r\n   {\r\n    \"start\": [4, 13],\r\n    \"end\": [4, 8]\r\n   },\r\n   {\r\n    \"start\": [6, 13],\r\n    \"end\": [6, 10]\r\n   },\r\n   {\r\n    \"start\": [6, 10],\r\n    \"end\": [9, 10]\r\n   },\r\n   {\r\n    \"start\": [9, 10],\r\n    \"end\": [9, 13]\r\n   },\r\n   {\r\n    \"start\": [11, 15],\r\n    \"end\": [11, 10]\r\n   },\r\n   {\r\n    \"start\": [4, 0],\r\n    \"end\": [4, 2]\r\n   },\r\n   {\r\n    \"start\": [4, 0],\r\n    \"end\": [15, 0]\r\n   },\r\n    {\r\n    \"start\": [11, 0],\r\n    \"end\": [11, 2]\r\n   },\r\n   {\r\n    \"start\": [11, 2],\r\n    \"end\": [6, 2]\r\n   },\r\n   {\r\n    \"start\": [6, 2],\r\n    \"end\": [6, 6]\r\n   },\r\n   {\r\n    \"start\": [6, 4],\r\n    \"end\": [2, 4]\r\n   },\r\n   {\r\n    \"start\": [9, 2],\r\n    \"end\": [9, 4]\r\n   },\r\n   {\r\n    \"start\": [15, 0],\r\n    \"end\": [15, 15]\r\n   },\r\n   {\r\n    \"start\": [15, 6],\r\n    \"end\": [13, 6]\r\n   },\r\n   {\r\n    \"start\": [13, 6],\r\n    \"end\": [13, 2]\r\n   },\r\n   {\r\n    \"start\": [15, 15],\r\n    \"end\": [13, 15]\r\n   },\r\n   {\r\n    \"start\": [13, 15],\r\n    \"end\": [13, 8]\r\n   },\r\n   {\r\n    \"start\": [13, 8],\r\n    \"end\": [11, 8]\r\n   },\r\n   {\r\n    \"start\": [4, 8],\r\n    \"end\": [9, 8]\r\n   },\r\n   {\r\n    \"start\": [9, 8],\r\n    \"end\": [9, 6]\r\n   },\r\n   {\r\n    \"start\": [9, 6],\r\n    \"end\": [11, 6]\r\n   },\r\n   {\r\n    \"start\": [11, 6],\r\n    \"end\": [11, 4]\r\n   }\r\n  ]\r\n\r\ndef add_segments_to_grid(grid_map, segments, resolution):\r\n    for seg in segments:\r\n        (x0, y0), (x1, y1) = seg['start'], seg['end']\r\n        gx0, gy0 = int(x0 / resolution), int(y0 / resolution)\r\n        gx1, gy1 = int(x1 / resolution), int(y1 / resolution)\r\n        rr, cc = line(gy0, gx0, gy1, gx1)\r\n        rr = np.clip(rr, 0, grid_map.shape[0] - 1)\r\n        cc = np.clip(cc, 0, grid_map.shape[1] - 1)\r\n        grid_map[rr, cc] = 1\r\n\r\ndef get_global_map():\r\n    grid_map = np.zeros((MAP_SIZE, MAP_SIZE), dtype=np.uint8)\r\n    add_segments_to_grid(grid_map, SEGMENTS, MAP_RESOLUTION)\r\n    return grid_map
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/config/map.py b/config/map.py
--- a/config/map.py	(revision 298ac29f37e3999bd2e2504354a68a98f8c62904)
+++ b/config/map.py	(date 1751471882905)
@@ -148,4 +148,4 @@
 def get_global_map():
     grid_map = np.zeros((MAP_SIZE, MAP_SIZE), dtype=np.uint8)
     add_segments_to_grid(grid_map, SEGMENTS, MAP_RESOLUTION)
-    return grid_map
\ No newline at end of file
+    return grid_map
Index: slam/slam.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import time\r\nimport math\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom breezyslam.algorithms import RMHC_SLAM\r\nfrom breezyslam.sensors import Laser\r\nfrom roboviz import MapVisualizer\r\nfrom config.map import get_global_map\r\nfrom config.settings import START_POSITION, EXIT_POSITION, MAP_RESOLUTION\r\nimport heapq\r\nfrom exploration.frontier_detect import ExplorationManager, world_to_grid, grid_to_world, is_exploration_complete, \\\r\n    detect_frontiers\r\nfrom matplotlib.patches import Circle\r\n\r\n\r\nclass CarSLAM:\r\n    def __init__(self, map_size_pixels=1024, map_size_meters=18.0, laser_params=None, grid_map=None):\r\n        # åˆå§‹åŒ–æ¿€å…‰æ¨¡å‹ï¼ˆç¤ºä¾‹å‚æ•°ï¼Œéœ€æ ¹æ®å®é™…æ¿€å…‰é›·è¾¾è°ƒæ•´ï¼‰\r\n        self.laser = Laser(scan_size=360, scan_rate_hz=100, detection_angle_degrees=360,\r\n                           distance_no_detection_mm=10000, detection_margin=0, offset_mm=0)\r\n        # åˆå§‹åŒ–SLAMå¯¹è±¡\r\n        self.slam = RMHC_SLAM(self.laser, map_size_pixels, map_size_meters)\r\n        self.mapbytes = bytearray(map_size_pixels * map_size_pixels)\r\n        # åˆå§‹åŒ–å¯è§†åŒ–å·¥å…·\r\n        self.viz = MapVisualizer(map_size_pixels, map_size_meters, 'Car SLAM Visualization')\r\n        # æ–°å¢ï¼šä¿å­˜éšœç¢ç‰©åœ°å›¾\r\n        self.grid_map = grid_map\r\n\r\n    def update_position(self, lidar_scan, pose_change, x, y, theta):\r\n        # å‡è®¾lidar_scanæ˜¯å½“å‰æ¿€å…‰é›·è¾¾æ‰«ææ•°æ®ï¼ˆåˆ—è¡¨å½¢å¼ï¼‰\r\n        # æ›´æ–°SLAMï¼ˆä¼ å…¥é‡Œç¨‹è®¡æ•°æ®ï¼‰\r\n        self.slam.update(lidar_scan, pose_change)\r\n        # è·å–æ›´ç²¾ç¡®çš„ä½ç½®\r\n        x_mm, y_mm, theta_degrees = self.slam.getpos()\r\n        # æ›´æ–°åœ°å›¾\r\n        self.slam.getmap(self.mapbytes)\r\n        # æ˜¾ç¤ºåœ°å›¾å’Œå½“å‰ä½ç½®ï¼ˆè½¬æ¢ä¸ºç±³ï¼‰\r\n        self.viz.display(x_mm / 1000, y_mm / 1000, theta_degrees, self.mapbytes)\r\n        return x_mm, y_mm, theta_degrees\r\n\r\n    def simulate_straight_line(self, distance_mm=8000, step_mm=100):\r\n        \"\"\"æ²¿ç›´çº¿ç§»åŠ¨å°è½¦å¹¶æ›´æ–°SLAMåœ°å›¾ï¼Œèµ·ç‚¹ä¸º START_POSITION\"\"\"\r\n        # èµ·ç‚¹ï¼ˆç±³è½¬æ¯«ç±³ï¼‰\r\n        x = START_POSITION['x'] * 1000\r\n        y = START_POSITION['y'] * 1000\r\n        theta = START_POSITION['theta']\r\n        for _ in range(int(distance_mm / step_mm)):\r\n            x += step_mm * np.cos(np.deg2rad(theta))\r\n            y += step_mm * np.sin(np.deg2rad(theta))\r\n            lidar_scan = generate_lidar_scan_from_gridmap(x, y, theta, self.grid_map, MAP_RESOLUTION)\r\n            pose_change = (step_mm, 0, 0)  # å‰è¿›step_mmï¼Œæ— ä¾§å‘ç§»åŠ¨ï¼Œæ— æ—‹è½¬\r\n            self.update_position(lidar_scan, pose_change, x, y, theta)\r\n            time.sleep(0.1)\r\n        plt.pause(0.5)\r\n\r\n    def simulate_curved_path(self, start_x_mm=1000, start_y_mm=5000, start_theta_deg=0, radius_mm=5000, angle_deg=90,\r\n                             step_mm=100):\r\n        \"\"\"æ¨¡æ‹Ÿå°è½¦æ²¿åœ†å¼§è·¯å¾„è¿åŠ¨\"\"\"\r\n        # è½¬æ¢è§’åº¦ä¸ºå¼§åº¦\r\n        angle_rad = math.radians(angle_deg)\r\n        start_theta_rad = math.radians(start_theta_deg)\r\n\r\n        # è®¡ç®—åœ†å¼§é•¿åº¦å’Œæ­¥æ•°\r\n        arc_length_mm = radius_mm * angle_rad\r\n        num_steps = max(1, int(arc_length_mm / step_mm))\r\n\r\n        # è®¡ç®—åœ†å¿ƒä½ç½®ï¼ˆå·¦è½¬ï¼‰\r\n        center_x = start_x_mm + radius_mm * math.cos(start_theta_rad + math.pi / 2)\r\n        center_y = start_y_mm + radius_mm * math.sin(start_theta_rad + math.pi / 2)\r\n\r\n        x, y, theta = start_x_mm, start_y_mm, start_theta_deg\r\n\r\n        for i in range(num_steps):\r\n            # è®¡ç®—å½“å‰è§’åº¦å’Œä½ç½®\r\n            current_angle_rad = start_theta_rad + (i / num_steps) * angle_rad + math.pi / 2\r\n            x = center_x - radius_mm * math.cos(current_angle_rad)\r\n            y = center_y - radius_mm * math.sin(current_angle_rad)\r\n            theta = start_theta_deg + (i / num_steps) * angle_deg\r\n\r\n            # ç”Ÿæˆæ¿€å…‰æ‰«ææ•°æ®\r\n            lidar_scan = generate_square_lidar_scan(x, y, theta)\r\n\r\n            # è®¡ç®—æ­¥é•¿å’Œè§’åº¦å˜åŒ–\r\n            delta_theta = angle_deg / num_steps\r\n            pose_change = (step_mm, delta_theta, 0)\r\n\r\n            # æ›´æ–°SLAMä½ç½®\r\n            self.update_position(lidar_scan, pose_change, x, y, theta)\r\n            time.sleep(0.1)\r\n\r\n        plt.pause(0.5)\r\n\r\n\r\ndef generate_square_lidar_scan(x_mm, y_mm, theta_deg, field_length_mm=20000, field_width_mm=10000, max_range_mm=10000):\r\n    \"\"\"æ¨¡æ‹Ÿé•¿æ–¹å½¢åœºåœ°ä¸­çš„æ¿€å…‰é›·è¾¾æ‰«ææ•°æ®\"\"\"\r\n    scan = []\r\n    theta_rad = math.radians(theta_deg)\r\n    half_fov = math.radians(180)  # å‡è®¾æ¿€å…‰é›·è¾¾æ°´å¹³è§†åœºè§’ä¸º360åº¦\r\n    step = 2 * half_fov / 359  # 360ä¸ªæ‰«æç‚¹\r\n\r\n    for i in range(360):\r\n        angle = theta_rad - half_fov + i * step\r\n        dx = math.cos(angle)\r\n        dy = math.sin(angle)\r\n\r\n        # è®¡ç®—åˆ°é•¿æ–¹å½¢åœºåœ°è¾¹ç•Œçš„è·ç¦»\r\n        t = float('inf')\r\n\r\n        # å·¦è¾¹ç•Œ (x=0)\r\n        if dx < 0:\r\n            t_left = (0 - x_mm) / dx\r\n            if t_left > 0:\r\n                y_intersect = y_mm + dy * t_left\r\n                if 0 <= y_intersect <= field_width_mm:\r\n                    t = min(t, t_left)\r\n\r\n        # å³è¾¹ç•Œ (x=field_length_mm)\r\n        if dx > 0:\r\n            t_right = (field_length_mm - x_mm) / dx\r\n            if t_right > 0:\r\n                y_intersect = y_mm + dy * t_right\r\n                if 0 <= y_intersect <= field_width_mm:\r\n                    t = min(t, t_right)\r\n\r\n        # ä¸‹è¾¹ç•Œ (y=0)\r\n        if dy < 0:\r\n            t_bottom = (0 - y_mm) / dy\r\n            if t_bottom > 0:\r\n                x_intersect = x_mm + dx * t_bottom\r\n                if 0 <= x_intersect <= field_length_mm:\r\n                    t = min(t, t_bottom)\r\n\r\n        # ä¸Šè¾¹ç•Œ (y=field_width_mm)\r\n        if dy > 0:\r\n            t_top = (field_width_mm - y_mm) / dy\r\n            if t_top > 0:\r\n                x_intersect = x_mm + dx * t_top\r\n                if 0 <= x_intersect <= field_length_mm:\r\n                    t = min(t, t_top)\r\n\r\n        distance = t if t != float('inf') else max_range_mm\r\n        scan.append(min(distance, max_range_mm))\r\n\r\n    return scan\r\n\r\n\r\ndef generate_lidar_scan_from_gridmap(x_mm, y_mm, theta_deg, grid_map, map_resolution, max_range_mm=4000, scan_size=360):\r\n    \"\"\"\r\n    åŸºäºæ …æ ¼åœ°å›¾çš„æ¿€å…‰é›·è¾¾æ¨¡æ‹Ÿã€‚\r\n    x_mm, y_mm: æœºå™¨äººä½ç½®ï¼ˆæ¯«ç±³ï¼‰\r\n    theta_deg: æœºå™¨äººæœå‘ï¼ˆåº¦ï¼‰\r\n    grid_map: 2D numpy arrayï¼Œéšœç¢ç‰©ä¸º1\r\n    map_resolution: æ¯æ ¼ç±³æ•°\r\n    max_range_mm: æœ€å¤§æ¢æµ‹è·ç¦»ï¼ˆæ¯«ç±³ï¼‰\r\n    scan_size: æ¿€å…‰æŸæ•°\r\n    è¿”å›: é•¿åº¦ä¸º scan_size çš„è·ç¦»æ•°ç»„ï¼ˆæ¯«ç±³ï¼‰\r\n    \"\"\"\r\n    scan = []\r\n    map_h, map_w = grid_map.shape\r\n    x0 = x_mm / 1000 / map_resolution  # è½¬ä¸ºæ ¼å­åæ ‡\r\n    y0 = y_mm / 1000 / map_resolution\r\n    for i in range(scan_size):\r\n        angle = math.radians(theta_deg) + 2 * math.pi * i / scan_size\r\n        dx = math.cos(angle)\r\n        dy = math.sin(angle)\r\n        # DDA/Bresenham\r\n        for r in range(1, int(max_range_mm / (map_resolution * 1000))):\r\n            x = x0 + dx * r\r\n            y = y0 + dy * r\r\n            xi, yi = int(round(x)), int(round(y))\r\n            if xi < 0 or xi >= map_w or yi < 0 or yi >= map_h:\r\n                distance = r * map_resolution * 1000\r\n                break\r\n            if grid_map[yi, xi] == 1:\r\n                distance = r * map_resolution * 1000\r\n                break\r\n        else:\r\n            distance = max_range_mm\r\n        scan.append(distance)\r\n    return scan\r\n\r\n\r\n# ========== å¸¸é‡å®šä¹‰ ==========\r\nLIDAR_ANGLE_RES = 1  # æ¯1åº¦ä¸€æŸæ¿€å…‰ï¼Œ360æŸ\r\nLIDAR_NUM = 360\r\nLIDAR_MAX_DIST = 20.0  # æ¿€å…‰æœ€å¤§æ¢æµ‹è·ç¦»ï¼ˆç±³ï¼Œå¯æ ¹æ®éœ€è¦è°ƒæ•´ï¼‰\r\n\r\n\r\n# ========== A* è·¯å¾„è§„åˆ’ ==========\r\ndef astar(start, goal, occ_map, map_resolution, map_size):\r\n    sx, sy = world_to_grid(start[0], start[1], map_resolution)\r\n    gx, gy = world_to_grid(goal[0], goal[1], map_resolution)\r\n    open_set = []\r\n    heapq.heappush(open_set, (0, (sx, sy)))\r\n    came_from = {}\r\n    g_score = {(sx, sy): 0}\r\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\r\n    while open_set:\r\n        _, current = heapq.heappop(open_set)\r\n        if current == (gx, gy):\r\n            path = [current]\r\n            while current in came_from:\r\n                current = came_from[current]\r\n                path.append(current)\r\n            path.reverse()\r\n            return [grid_to_world(x, y, map_resolution) for x, y in path]\r\n        for dx, dy in dirs:\r\n            nx, ny = current[0] + dx, current[1] + dy\r\n            if 0 <= nx < map_size and 0 <= ny < map_size and occ_map[ny, nx] != 1:\r\n                tentative_g = g_score[current] + np.hypot(dx, dy)\r\n                if (nx, ny) not in g_score or tentative_g < g_score[(nx, ny)]:\r\n                    g_score[(nx, ny)] = tentative_g\r\n                    f = tentative_g + np.hypot(gx - nx, gy - ny)\r\n                    heapq.heappush(open_set, (f, (nx, ny)))\r\n                    came_from[(nx, ny)] = current\r\n    return None\r\n\r\n\r\n# ========== åœ°å›¾æ›´æ–° ==========\r\ndef update_known_map(pos, scan, known_map, robot_theta, map_resolution, lidar_angle_res, lidar_max_dist):\r\n    for i, dist in enumerate(scan):\r\n        angle = np.deg2rad(i * lidar_angle_res)\r\n        a = robot_theta + angle\r\n        for r in np.arange(0, min(dist, lidar_max_dist), map_resolution / 2):\r\n            x = pos[0] + r * np.cos(a)\r\n            y = pos[1] + r * np.sin(a)\r\n            gx, gy = world_to_grid(x, y, map_resolution)\r\n            if gx < 0 or gx >= known_map.shape[1] or gy < 0 or gy >= known_map.shape[0]:\r\n                break\r\n            if known_map[gy, gx] == -1:\r\n                known_map[gy, gx] = 0\r\n        if dist < lidar_max_dist:\r\n            x = pos[0] + dist * np.cos(a)\r\n            y = pos[1] + dist * np.sin(a)\r\n            gx, gy = world_to_grid(x, y, map_resolution)\r\n            if 0 <= gx < known_map.shape[1] and 0 <= gy < known_map.shape[0]:\r\n                known_map[gy, gx] = 1\r\n\r\n\r\ndef is_frontier(known_map, gx, gy):\r\n    if known_map[gy, gx] != 0:\r\n        return False\r\n    # åªè¦æœ‰ä¸€ä¸ªé‚»å±…æ˜¯æœªçŸ¥åŒºï¼Œå°±æ˜¯frontier\r\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\r\n        nx, ny = gx + dx, gy + dy\r\n        if 0 <= nx < known_map.shape[1] and 0 <= ny < known_map.shape[0]:\r\n            if known_map[ny, nx] == -1:\r\n                return True\r\n    return False\r\n\r\n\r\n# ========== ä¸»å¾ªç¯ ==========\r\nif __name__ == '__main__':\r\n    try:\r\n        import matplotlib.pyplot as plt\r\n        from config.map import MAP_SIZE\r\n        from config.settings import ROBOT_RADIUS\r\n\r\n        true_map = get_global_map()\r\n        known_map = np.full_like(true_map, -1, dtype=float)\r\n        explorer = ExplorationManager(map_resolution=MAP_RESOLUTION)\r\n        robot_pos = np.array([START_POSITION['x'], START_POSITION['y']])\r\n        robot_theta = START_POSITION['theta']\r\n        trajectory = [robot_pos.copy()]\r\n        MAP_PIXELS = 1024\r\n        MAP_METERS = 20.0\r\n        PADDING = 7.0  # ç±³\r\n        MAP_METERS = MAP_METERS + 2 * PADDING\r\n        MAP_PIXELS = int(MAP_PIXELS + 2 * (PADDING / MAP_RESOLUTION))\r\n        slam = CarSLAM(map_size_pixels=MAP_PIXELS, map_size_meters=MAP_METERS, grid_map=true_map)\r\n        plt.ion()\r\n        fig, ax = plt.subplots(figsize=(8, 8))\r\n        # å…ˆç”¨èµ·ç‚¹ä½ç½®åšä¸€æ¬¡æ¿€å…‰æ‰«æï¼Œæ›´æ–°å·²çŸ¥åœ°å›¾\r\n        scan_mm = generate_lidar_scan_from_gridmap(\r\n            robot_pos[0] * 1000, robot_pos[1] * 1000, np.rad2deg(robot_theta),\r\n            true_map, MAP_RESOLUTION, max_range_mm=int(LIDAR_MAX_DIST * 1000), scan_size=LIDAR_NUM)\r\n        scan = np.array(scan_mm) / 1000.0  # è½¬ä¸ºç±³\r\n        update_known_map(robot_pos, scan, known_map, robot_theta, MAP_RESOLUTION, LIDAR_ANGLE_RES, LIDAR_MAX_DIST)\r\n        print('æ¿€å…‰åˆå§‹åŒ–åå·²çŸ¥åœ°å›¾ç©ºåœ°æ•°ï¼š', np.sum(known_map == 0))\r\n        test_frontiers = explorer.get_next_target(known_map, robot_pos)\r\n        print('æ¿€å…‰åˆå§‹åŒ–åå‰æ²¿ç‚¹ï¼ˆç›®æ ‡ï¼‰:', test_frontiers)\r\n        print('è¿›å…¥ä¸»å¾ªç¯')\r\n        step_size = 0.1  # æ¯æ¬¡å‰è¿›0.1ç±³\r\n        turn_step = np.deg2rad(5)  # æ¯æ¬¡æœ€å¤šè½¬5åº¦\r\n        while True:\r\n            # 1. ç”¨çœŸå®åœ°å›¾æ¨¡æ‹Ÿæ¿€å…‰\r\n            scan_mm = generate_lidar_scan_from_gridmap(\r\n                robot_pos[0] * 1000, robot_pos[1] * 1000, np.rad2deg(robot_theta),\r\n                true_map, MAP_RESOLUTION, max_range_mm=int(LIDAR_MAX_DIST * 1000), scan_size=LIDAR_NUM)\r\n            scan = np.array(scan_mm) / 1000.0  # è½¬ä¸ºç±³\r\n            # 2. æ›´æ–°å·²çŸ¥åœ°å›¾\r\n            update_known_map(robot_pos, scan, known_map, robot_theta, MAP_RESOLUTION, LIDAR_ANGLE_RES, LIDAR_MAX_DIST)\r\n            # 3. æ¢ç´¢é€»è¾‘\r\n            # è·å–æ‰€æœ‰frontierç‚¹\r\n            frontiers = detect_frontiers(known_map, unknown_val=-1, free_threshold=0.2, map_resolution=MAP_RESOLUTION)\r\n            target = None\r\n            for f in frontiers:\r\n                gx, gy = world_to_grid(f[0], f[1], MAP_RESOLUTION)\r\n                if known_map[gy, gx] == 0:\r\n                    target = f\r\n                    break\r\n            if target is None:\r\n                print('æ¢ç´¢å®Œæˆï¼')\r\n                break\r\n            print(f'å½“å‰æœºå™¨äººä½ç½®: {robot_pos}, theta(rad): {robot_theta:.2f}')\r\n            print(f'å½“å‰å·²çŸ¥ç©ºåœ°æ•°: {np.sum(known_map == 0)}, å‰æ²¿ç‚¹: {target}')\r\n            path = astar(robot_pos, target, known_map, MAP_RESOLUTION, MAP_SIZE)\r\n            if path is None or len(path) < 2:\r\n                print(f'æ— æ³•åˆ°è¾¾ç›®æ ‡ï¼Œpath={path}ï¼Œtarget={target}ï¼Œrobot_pos={robot_pos}')\r\n                gx, gy = world_to_grid(target[0], target[1], MAP_RESOLUTION)\r\n                print(f\"A*å¤±è´¥ï¼Œç›®æ ‡ç‚¹æ ¼å­({gx},{gy})ï¼Œknown_mapå€¼={known_map[gy, gx]}\")\r\n                print(\r\n                    f\"robot_pos={robot_pos}, robotæ ¼å­={world_to_grid(robot_pos[0], robot_pos[1], MAP_RESOLUTION)}, known_mapå€¼={known_map[world_to_grid(robot_pos[1], robot_pos[0], MAP_RESOLUTION)]}\")\r\n                # å¯è§†åŒ–known_mapï¼Œæ ‡å‡ºrobotå’Œtarget\r\n                plt.imshow(known_map, cmap='Blues', origin='lower')\r\n                plt.plot(gx, gy, 'rx', label='target')\r\n                rx, ry = world_to_grid(robot_pos[0], robot_pos[1], MAP_RESOLUTION)\r\n                plt.plot(rx, ry, 'go', label='robot')\r\n                plt.legend()\r\n                plt.title('A*å¤±è´¥æ—¶çš„å·²çŸ¥åœ°å›¾')\r\n                plt.show()\r\n                continue\r\n            # === å¹³æ»‘è¿åŠ¨åˆ°ä¸‹ä¸€ä¸ªA*ç‚¹ ===\r\n            for i in range(1, len(path)):\r\n                target_pos = np.array(path[i])\r\n                while True:\r\n                    delta = target_pos - robot_pos\r\n                    dist = np.linalg.norm(delta)\r\n                    target_theta = np.arctan2(delta[1], delta[0])\r\n                    dtheta = target_theta - robot_theta\r\n                    dtheta = (dtheta + np.pi) % (2 * np.pi) - np.pi\r\n                    if abs(dtheta) > 1e-2:\r\n                        turn = np.clip(dtheta, -turn_step, turn_step)\r\n                        robot_theta += turn\r\n                        pose_change = (0, turn, 0)\r\n                    else:\r\n                        move = min(step_size, dist)\r\n                        robot_pos += move * np.array([np.cos(robot_theta), np.sin(robot_theta)])\r\n                        pose_change = (move * 1000, 0, 0)\r\n                    # æ¿€å…‰æ¨¡æ‹Ÿ\r\n                    scan_mm = generate_lidar_scan_from_gridmap(\r\n                        robot_pos[0] * 1000, robot_pos[1] * 1000, np.rad2deg(robot_theta),\r\n                        true_map, MAP_RESOLUTION, max_range_mm=int(LIDAR_MAX_DIST * 1000), scan_size=LIDAR_NUM)\r\n                    scan = np.array(scan_mm) / 1000.0\r\n                    update_known_map(robot_pos, scan, known_map, robot_theta, MAP_RESOLUTION, LIDAR_ANGLE_RES,\r\n                                     LIDAR_MAX_DIST)\r\n                    slam.update_position(scan_mm, pose_change, robot_pos[0] * 1000, robot_pos[1] * 1000,\r\n                                         np.rad2deg(robot_theta))\r\n                    trajectory.append(robot_pos.copy())\r\n                    # å¯è§†åŒ–\r\n                    ax.clear()\r\n                    # åœ°å›¾é™æ­¢æ˜¾ç¤ºï¼Œorigin='lower'\r\n                    ax.imshow(true_map, cmap='gray_r', alpha=0.3, origin='lower')\r\n                    show_map = known_map.copy()\r\n                    show_map[show_map == -1] = 0.5\r\n                    ax.imshow(show_map, cmap='Blues', alpha=0.5, origin='lower')\r\n                    # è½¨è¿¹å’Œå°è½¦ä½ç½®ç”¨ä¸–ç•Œåæ ‡\r\n                    ax.plot([p[0] / MAP_RESOLUTION for p in trajectory], [p[1] / MAP_RESOLUTION for p in trajectory],\r\n                            'g.-', linewidth=2)\r\n                    ax.plot(robot_pos[0] / MAP_RESOLUTION, robot_pos[1] / MAP_RESOLUTION, 'ro', markersize=8)\r\n                    if target is not None:\r\n                        ax.plot(target[0] / MAP_RESOLUTION, target[1] / MAP_RESOLUTION, 'yx', markersize=12)\r\n                        ax.plot(target[0] / MAP_RESOLUTION, target[1] / MAP_RESOLUTION, marker='*', color='y',\r\n                                markersize=18)\r\n                    ax.set_xlim(0, MAP_SIZE)\r\n                    ax.set_ylim(0, MAP_SIZE)\r\n                    circle = Circle((robot_pos[0] / MAP_RESOLUTION, robot_pos[1] / MAP_RESOLUTION),\r\n                                    radius=ROBOT_RADIUS / MAP_RESOLUTION, fill=False, color='r', linestyle='--')\r\n                    ax.add_patch(circle)\r\n                    ax.set_title('SLAM Exploration')\r\n                    plt.pause(0.01)\r\n                    if abs(dtheta) <= 1e-2 and dist < step_size:\r\n                        break\r\n                # === Graph SLAMèŠ‚ç‚¹é‡‡æ ·ï¼šæ¯åˆ°è¾¾A*ä¸‹ä¸€ä¸ªç‚¹æ—¶é‡‡æ · ===\r\n                # ä½ å¯ä»¥åœ¨è¿™é‡ŒåŠ Graph SLAMèŠ‚ç‚¹å’Œè¾¹çš„é‡‡æ ·é€»è¾‘\r\n        plt.ioff()\r\n        plt.show()\r\n        input('æŒ‰å›è½¦é€€å‡º...')\r\n    except Exception as e:\r\n        import traceback\r\n\r\n        print('å…¨å±€å¼‚å¸¸:', e)\r\n        traceback.print_exc()\r\n        input('æŒ‰å›è½¦é€€å‡º...')
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/slam/slam.py b/slam/slam.py
--- a/slam/slam.py	(revision 298ac29f37e3999bd2e2504354a68a98f8c62904)
+++ b/slam/slam.py	(date 1751472154021)
@@ -8,8 +8,7 @@
 from config.map import get_global_map
 from config.settings import START_POSITION, EXIT_POSITION, MAP_RESOLUTION
 import heapq
-from exploration.frontier_detect import ExplorationManager, world_to_grid, grid_to_world, is_exploration_complete, \
-    detect_frontiers
+from exploration.frontier_detect import ExplorationManager, world_to_grid, grid_to_world, is_exploration_complete, detect_frontiers
 from matplotlib.patches import Circle
 
 
@@ -143,7 +142,6 @@
 
     return scan
 
-
 def generate_lidar_scan_from_gridmap(x_mm, y_mm, theta_deg, grid_map, map_resolution, max_range_mm=4000, scan_size=360):
     """
     åŸºäºæ …æ ¼åœ°å›¾çš„æ¿€å…‰é›·è¾¾æ¨¡æ‹Ÿã€‚
@@ -179,13 +177,11 @@
         scan.append(distance)
     return scan
 
-
 # ========== å¸¸é‡å®šä¹‰ ==========
 LIDAR_ANGLE_RES = 1  # æ¯1åº¦ä¸€æŸæ¿€å…‰ï¼Œ360æŸ
 LIDAR_NUM = 360
 LIDAR_MAX_DIST = 20.0  # æ¿€å…‰æœ€å¤§æ¢æµ‹è·ç¦»ï¼ˆç±³ï¼Œå¯æ ¹æ®éœ€è¦è°ƒæ•´ï¼‰
 
-
 # ========== A* è·¯å¾„è§„åˆ’ ==========
 def astar(start, goal, occ_map, map_resolution, map_size):
     sx, sy = world_to_grid(start[0], start[1], map_resolution)
@@ -194,7 +190,7 @@
     heapq.heappush(open_set, (0, (sx, sy)))
     came_from = {}
     g_score = {(sx, sy): 0}
-    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]
+    dirs = [(-1,0),(1,0),(0,-1),(0,1),(-1,-1),(-1,1),(1,-1),(1,1)]
     while open_set:
         _, current = heapq.heappop(open_set)
         if current == (gx, gy):
@@ -205,23 +201,22 @@
             path.reverse()
             return [grid_to_world(x, y, map_resolution) for x, y in path]
         for dx, dy in dirs:
-            nx, ny = current[0] + dx, current[1] + dy
+            nx, ny = current[0]+dx, current[1]+dy
             if 0 <= nx < map_size and 0 <= ny < map_size and occ_map[ny, nx] != 1:
                 tentative_g = g_score[current] + np.hypot(dx, dy)
                 if (nx, ny) not in g_score or tentative_g < g_score[(nx, ny)]:
                     g_score[(nx, ny)] = tentative_g
-                    f = tentative_g + np.hypot(gx - nx, gy - ny)
+                    f = tentative_g + np.hypot(gx-nx, gy-ny)
                     heapq.heappush(open_set, (f, (nx, ny)))
                     came_from[(nx, ny)] = current
     return None
 
-
 # ========== åœ°å›¾æ›´æ–° ==========
 def update_known_map(pos, scan, known_map, robot_theta, map_resolution, lidar_angle_res, lidar_max_dist):
     for i, dist in enumerate(scan):
         angle = np.deg2rad(i * lidar_angle_res)
         a = robot_theta + angle
-        for r in np.arange(0, min(dist, lidar_max_dist), map_resolution / 2):
+        for r in np.arange(0, min(dist, lidar_max_dist), map_resolution/2):
             x = pos[0] + r * np.cos(a)
             y = pos[1] + r * np.sin(a)
             gx, gy = world_to_grid(x, y, map_resolution)
@@ -236,26 +231,23 @@
             if 0 <= gx < known_map.shape[1] and 0 <= gy < known_map.shape[0]:
                 known_map[gy, gx] = 1
 
-
 def is_frontier(known_map, gx, gy):
     if known_map[gy, gx] != 0:
         return False
     # åªè¦æœ‰ä¸€ä¸ªé‚»å±…æ˜¯æœªçŸ¥åŒºï¼Œå°±æ˜¯frontier
-    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
-        nx, ny = gx + dx, gy + dy
+    for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
+        nx, ny = gx+dx, gy+dy
         if 0 <= nx < known_map.shape[1] and 0 <= ny < known_map.shape[0]:
             if known_map[ny, nx] == -1:
                 return True
     return False
 
-
 # ========== ä¸»å¾ªç¯ ==========
 if __name__ == '__main__':
     try:
         import matplotlib.pyplot as plt
         from config.map import MAP_SIZE
         from config.settings import ROBOT_RADIUS
-
         true_map = get_global_map()
         known_map = np.full_like(true_map, -1, dtype=float)
         explorer = ExplorationManager(map_resolution=MAP_RESOLUTION)
@@ -269,11 +261,11 @@
         MAP_PIXELS = int(MAP_PIXELS + 2 * (PADDING / MAP_RESOLUTION))
         slam = CarSLAM(map_size_pixels=MAP_PIXELS, map_size_meters=MAP_METERS, grid_map=true_map)
         plt.ion()
-        fig, ax = plt.subplots(figsize=(8, 8))
+        fig, ax = plt.subplots(figsize=(8,8))
         # å…ˆç”¨èµ·ç‚¹ä½ç½®åšä¸€æ¬¡æ¿€å…‰æ‰«æï¼Œæ›´æ–°å·²çŸ¥åœ°å›¾
         scan_mm = generate_lidar_scan_from_gridmap(
-            robot_pos[0] * 1000, robot_pos[1] * 1000, np.rad2deg(robot_theta),
-            true_map, MAP_RESOLUTION, max_range_mm=int(LIDAR_MAX_DIST * 1000), scan_size=LIDAR_NUM)
+            robot_pos[0]*1000, robot_pos[1]*1000, np.rad2deg(robot_theta),
+            true_map, MAP_RESOLUTION, max_range_mm=int(LIDAR_MAX_DIST*1000), scan_size=LIDAR_NUM)
         scan = np.array(scan_mm) / 1000.0  # è½¬ä¸ºç±³
         update_known_map(robot_pos, scan, known_map, robot_theta, MAP_RESOLUTION, LIDAR_ANGLE_RES, LIDAR_MAX_DIST)
         print('æ¿€å…‰åˆå§‹åŒ–åå·²çŸ¥åœ°å›¾ç©ºåœ°æ•°ï¼š', np.sum(known_map == 0))
@@ -285,8 +277,8 @@
         while True:
             # 1. ç”¨çœŸå®åœ°å›¾æ¨¡æ‹Ÿæ¿€å…‰
             scan_mm = generate_lidar_scan_from_gridmap(
-                robot_pos[0] * 1000, robot_pos[1] * 1000, np.rad2deg(robot_theta),
-                true_map, MAP_RESOLUTION, max_range_mm=int(LIDAR_MAX_DIST * 1000), scan_size=LIDAR_NUM)
+                robot_pos[0]*1000, robot_pos[1]*1000, np.rad2deg(robot_theta),
+                true_map, MAP_RESOLUTION, max_range_mm=int(LIDAR_MAX_DIST*1000), scan_size=LIDAR_NUM)
             scan = np.array(scan_mm) / 1000.0  # è½¬ä¸ºç±³
             # 2. æ›´æ–°å·²çŸ¥åœ°å›¾
             update_known_map(robot_pos, scan, known_map, robot_theta, MAP_RESOLUTION, LIDAR_ANGLE_RES, LIDAR_MAX_DIST)
@@ -309,8 +301,7 @@
                 print(f'æ— æ³•åˆ°è¾¾ç›®æ ‡ï¼Œpath={path}ï¼Œtarget={target}ï¼Œrobot_pos={robot_pos}')
                 gx, gy = world_to_grid(target[0], target[1], MAP_RESOLUTION)
                 print(f"A*å¤±è´¥ï¼Œç›®æ ‡ç‚¹æ ¼å­({gx},{gy})ï¼Œknown_mapå€¼={known_map[gy, gx]}")
-                print(
-                    f"robot_pos={robot_pos}, robotæ ¼å­={world_to_grid(robot_pos[0], robot_pos[1], MAP_RESOLUTION)}, known_mapå€¼={known_map[world_to_grid(robot_pos[1], robot_pos[0], MAP_RESOLUTION)]}")
+                print(f"robot_pos={robot_pos}, robotæ ¼å­={world_to_grid(robot_pos[0], robot_pos[1], MAP_RESOLUTION)}, known_mapå€¼={known_map[world_to_grid(robot_pos[1], robot_pos[0], MAP_RESOLUTION)]}")
                 # å¯è§†åŒ–known_mapï¼Œæ ‡å‡ºrobotå’Œtarget
                 plt.imshow(known_map, cmap='Blues', origin='lower')
                 plt.plot(gx, gy, 'rx', label='target')
@@ -339,13 +330,11 @@
                         pose_change = (move * 1000, 0, 0)
                     # æ¿€å…‰æ¨¡æ‹Ÿ
                     scan_mm = generate_lidar_scan_from_gridmap(
-                        robot_pos[0] * 1000, robot_pos[1] * 1000, np.rad2deg(robot_theta),
-                        true_map, MAP_RESOLUTION, max_range_mm=int(LIDAR_MAX_DIST * 1000), scan_size=LIDAR_NUM)
+                        robot_pos[0]*1000, robot_pos[1]*1000, np.rad2deg(robot_theta),
+                        true_map, MAP_RESOLUTION, max_range_mm=int(LIDAR_MAX_DIST*1000), scan_size=LIDAR_NUM)
                     scan = np.array(scan_mm) / 1000.0
-                    update_known_map(robot_pos, scan, known_map, robot_theta, MAP_RESOLUTION, LIDAR_ANGLE_RES,
-                                     LIDAR_MAX_DIST)
-                    slam.update_position(scan_mm, pose_change, robot_pos[0] * 1000, robot_pos[1] * 1000,
-                                         np.rad2deg(robot_theta))
+                    update_known_map(robot_pos, scan, known_map, robot_theta, MAP_RESOLUTION, LIDAR_ANGLE_RES, LIDAR_MAX_DIST)
+                    slam.update_position(scan_mm, pose_change, robot_pos[0]*1000, robot_pos[1]*1000, np.rad2deg(robot_theta))
                     trajectory.append(robot_pos.copy())
                     # å¯è§†åŒ–
                     ax.clear()
@@ -355,17 +344,14 @@
                     show_map[show_map == -1] = 0.5
                     ax.imshow(show_map, cmap='Blues', alpha=0.5, origin='lower')
                     # è½¨è¿¹å’Œå°è½¦ä½ç½®ç”¨ä¸–ç•Œåæ ‡
-                    ax.plot([p[0] / MAP_RESOLUTION for p in trajectory], [p[1] / MAP_RESOLUTION for p in trajectory],
-                            'g.-', linewidth=2)
-                    ax.plot(robot_pos[0] / MAP_RESOLUTION, robot_pos[1] / MAP_RESOLUTION, 'ro', markersize=8)
+                    ax.plot([p[0]/MAP_RESOLUTION for p in trajectory], [p[1]/MAP_RESOLUTION for p in trajectory], 'g.-', linewidth=2)
+                    ax.plot(robot_pos[0]/MAP_RESOLUTION, robot_pos[1]/MAP_RESOLUTION, 'ro', markersize=8)
                     if target is not None:
-                        ax.plot(target[0] / MAP_RESOLUTION, target[1] / MAP_RESOLUTION, 'yx', markersize=12)
-                        ax.plot(target[0] / MAP_RESOLUTION, target[1] / MAP_RESOLUTION, marker='*', color='y',
-                                markersize=18)
+                        ax.plot(target[0]/MAP_RESOLUTION, target[1]/MAP_RESOLUTION, 'yx', markersize=12)
+                        ax.plot(target[0]/MAP_RESOLUTION, target[1]/MAP_RESOLUTION, marker='*', color='y', markersize=18)
                     ax.set_xlim(0, MAP_SIZE)
                     ax.set_ylim(0, MAP_SIZE)
-                    circle = Circle((robot_pos[0] / MAP_RESOLUTION, robot_pos[1] / MAP_RESOLUTION),
-                                    radius=ROBOT_RADIUS / MAP_RESOLUTION, fill=False, color='r', linestyle='--')
+                    circle = Circle((robot_pos[0]/MAP_RESOLUTION, robot_pos[1]/MAP_RESOLUTION), radius=ROBOT_RADIUS/MAP_RESOLUTION, fill=False, color='r', linestyle='--')
                     ax.add_patch(circle)
                     ax.set_title('SLAM Exploration')
                     plt.pause(0.01)
@@ -378,7 +364,9 @@
         input('æŒ‰å›è½¦é€€å‡º...')
     except Exception as e:
         import traceback
-
+        print('å…¨å±€å¼‚å¸¸:', e)
+        traceback.print_exc()
+        input('æŒ‰å›è½¦é€€å‡º...')
         print('å…¨å±€å¼‚å¸¸:', e)
         traceback.print_exc()
         input('æŒ‰å›è½¦é€€å‡º...')
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"45e14498-f268-4c87-94ed-665d14b11296\" name=\"æ›´æ”¹\" comment=\"\">\r\n      <change afterPath=\"$PROJECT_DIR$/breezy_slam.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/config/map.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/config/map.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/exploration/test.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/exploration/test.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0282_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0282_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0282_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0282_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0283_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0283_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0283_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0283_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0284_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0284_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0284_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0284_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0285_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0285_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0285_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0285_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0286_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0286_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0286_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0286_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0287_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0287_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0287_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0287_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0288_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0288_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0288_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0288_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0289_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0289_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0289_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0289_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0290_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0290_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0290_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0290_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0291_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0291_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0291_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0291_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0292_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0292_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0292_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0292_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0293_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0293_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0293_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0293_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0294_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0294_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0294_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0294_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0295_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0295_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0295_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0295_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0296_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0296_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0296_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0296_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0297_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0297_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0297_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0297_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0298_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0298_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0298_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0298_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0299_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0299_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0299_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0299_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0300_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0300_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0300_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0300_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0301_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0301_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0301_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0301_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0302_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0302_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0302_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0302_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0303_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0303_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0303_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0303_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0304_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0304_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0304_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0304_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0305_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0305_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0305_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0305_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0306_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0306_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0306_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0306_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0307_map.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0307_pose.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0307_trajectory.npy\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/output/keyframes/keyframe_0307_viz.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/slam/slam.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/slam/slam.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 0\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2z8lhl5xzgQh1WwaW4BqdHz8aks\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\">\r\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\r\n  </component>\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"Python æµ‹è¯•.Python æµ‹è¯• (enhanced_test.py å†…).executor\": \"Run\",\r\n    \"Python æµ‹è¯•.Python æµ‹è¯• (roboviz_slam_viz.py å†…).executor\": \"Run\",\r\n    \"Python æµ‹è¯•.Python æµ‹è¯• (simple_test.py å†…).executor\": \"Run\",\r\n    \"Python æµ‹è¯•.Python æµ‹è¯• (simple_viz_test.py å†…).executor\": \"Run\",\r\n    \"Python æµ‹è¯•.Python æµ‹è¯• (slamtester.py å†…).executor\": \"Run\",\r\n    \"Python æµ‹è¯•.Python æµ‹è¯• (test_exploration_slam.py å†…).executor\": \"Run\",\r\n    \"Python æµ‹è¯•.Python æµ‹è¯• (test_frontier_detect.py å†…).executor\": \"Run\",\r\n    \"Python æµ‹è¯•.Python æµ‹è¯• (test_pythonrobotics_import.py å†…).executor\": \"Run\",\r\n    \"Python æµ‹è¯•.Python æµ‹è¯• (test_slam_exception.py å†…).executor\": \"Run\",\r\n    \"Python æµ‹è¯•.Python æµ‹è¯• (test_system.py å†…).executor\": \"Run\",\r\n    \"Python æµ‹è¯•.Python æµ‹è¯• (test_system_unittest.py å†…).executor\": \"Run\",\r\n    \"Python æµ‹è¯•.Python æµ‹è¯• (test_visualization.py å†…).executor\": \"Run\",\r\n    \"Python æµ‹è¯•.Python æµ‹è¯• (visualize_path.py å†…).executor\": \"Run\",\r\n    \"Python.SLAM.executor\": \"Run\",\r\n    \"Python.breezy_slam.executor\": \"Run\",\r\n    \"Python.breezy_slam_adapter.executor\": \"Run\",\r\n    \"Python.data_logger.executor\": \"Run\",\r\n    \"Python.demo_complete_system.executor\": \"Run\",\r\n    \"Python.dwa_planner.executor\": \"Run\",\r\n    \"Python.dynamic_window_approach.executor\": \"Run\",\r\n    \"Python.exit_detection.executor\": \"Run\",\r\n    \"Python.fast_slam1.executor\": \"Run\",\r\n    \"Python.frontier_detect.executor\": \"Run\",\r\n    \"Python.generate_map_segments.executor\": \"Run\",\r\n    \"Python.generate_map_trajectories.executor\": \"Run\",\r\n    \"Python.hybrid_a_star_planner.executor\": \"Run\",\r\n    \"Python.main.executor\": \"Run\",\r\n    \"Python.main_pipeline.executor\": \"Run\",\r\n    \"Python.map.executor\": \"Run\",\r\n    \"Python.map_viz.executor\": \"Run\",\r\n    \"Python.mapper.executor\": \"Run\",\r\n    \"Python.matplotlib_viz.executor\": \"Run\",\r\n    \"Python.move_to_pose.executor\": \"Run\",\r\n    \"Python.move_to_pose_robot.executor\": \"Run\",\r\n    \"Python.path_planner.executor\": \"Run\",\r\n    \"Python.plot.executor\": \"Run\",\r\n    \"Python.postprocess_path.executor\": \"Run\",\r\n    \"Python.roboviz_slam_demo.executor\": \"Run\",\r\n    \"Python.roboviz_slam_viz.executor\": \"Run\",\r\n    \"Python.run_slam_roboviz.executor\": \"Run\",\r\n    \"Python.settings.executor\": \"Run\",\r\n    \"Python.sim_explore_slam.executor\": \"Run\",\r\n    \"Python.simple_animation_demo.executor\": \"Run\",\r\n    \"Python.simple_exploration_demo.executor\": \"Run\",\r\n    \"Python.simple_test.executor\": \"Run\",\r\n    \"Python.simulate_exploration.executor\": \"Run\",\r\n    \"Python.simulate_exploration_new.executor\": \"Run\",\r\n    \"Python.slam.executor\": \"Run\",\r\n    \"Python.slam_demo.executor\": \"Run\",\r\n    \"Python.slam_simulation.executor\": \"Run\",\r\n    \"Python.test.executor\": \"Run\",\r\n    \"Python.test1.executor\": \"Run\",\r\n    \"Python.visualize_dwa_path.executor\": \"Run\",\r\n    \"Python.visualize_path.executor\": \"Run\",\r\n    \"Python.web_viz.executor\": \"Run\",\r\n    \"Python.æµ‹è¯•.executor\": \"Run\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"RunOnceActivity.git.unshallow\": \"true\",\r\n    \"git-widget-placeholder\": \"main\",\r\n    \"last_opened_file_path\": \"D:/PycharmProjects/PythonProject1\",\r\n    \"settings.editor.selected.configurable\": \"vcs.Git\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyFile.RECENT_KEYS\">\r\n      <recent name=\"D:\\PycharmProjects\\PythonProject1\" />\r\n      <recent name=\"D:\\PycharmProjects\\PythonProject1\\viz\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"breezy_slam_adapter\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"maze_robot_project\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"E:/OneDrive/æ–‡æ¡£/xwechat_files/wxid_02tq8nie0kio22_9a81/msg/file/2025-07\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"E:/OneDrive/æ–‡æ¡£/xwechat_files/wxid_02tq8nie0kio22_9a81/msg/file/2025-07/breezy_slam_adapter.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.breezy_slam_adapter\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-python-sdk-4f4e415b4190-aa17d162503b-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-243.26053.29\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"åº”ç”¨ç¨‹åºçº§\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"é»˜è®¤ä»»åŠ¡\">\r\n      <changelist id=\"45e14498-f268-4c87-94ed-665d14b11296\" name=\"æ›´æ”¹\" comment=\"\" />\r\n      <created>1751120701753</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1751120701753</updated>\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 298ac29f37e3999bd2e2504354a68a98f8c62904)
+++ b/.idea/workspace.xml	(date 1751472187172)
@@ -5,115 +5,10 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="45e14498-f268-4c87-94ed-665d14b11296" name="æ›´æ”¹" comment="">
-      <change afterPath="$PROJECT_DIR$/breezy_slam.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/config/map.py" beforeDir="false" afterPath="$PROJECT_DIR$/config/map.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/exploration/test.py" beforeDir="false" afterPath="$PROJECT_DIR$/exploration/test.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0282_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0282_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0282_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0282_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0283_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0283_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0283_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0283_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0284_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0284_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0284_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0284_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0285_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0285_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0285_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0285_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0286_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0286_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0286_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0286_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0287_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0287_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0287_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0287_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0288_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0288_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0288_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0288_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0289_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0289_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0289_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0289_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0290_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0290_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0290_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0290_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0291_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0291_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0291_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0291_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0292_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0292_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0292_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0292_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0293_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0293_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0293_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0293_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0294_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0294_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0294_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0294_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0295_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0295_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0295_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0295_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0296_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0296_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0296_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0296_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0297_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0297_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0297_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0297_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0298_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0298_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0298_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0298_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0299_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0299_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0299_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0299_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0300_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0300_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0300_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0300_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0301_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0301_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0301_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0301_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0302_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0302_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0302_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0302_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0303_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0303_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0303_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0303_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0304_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0304_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0304_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0304_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0305_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0305_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0305_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0305_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0306_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0306_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0306_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0306_viz.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0307_map.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0307_pose.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0307_trajectory.npy" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/output/keyframes/keyframe_0307_viz.png" beforeDir="false" />
       <change beforePath="$PROJECT_DIR$/slam/slam.py" beforeDir="false" afterPath="$PROJECT_DIR$/slam/slam.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/viz/roboviz_slam_viz.py" beforeDir="false" afterPath="$PROJECT_DIR$/viz/roboviz_slam_viz.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -201,7 +96,7 @@
     "Python.æµ‹è¯•.executor": "Run",
     "RunOnceActivity.ShowReadmeOnStart": "true",
     "RunOnceActivity.git.unshallow": "true",
-    "git-widget-placeholder": "main",
+    "git-widget-placeholder": "æ­£åœ¨åˆå¹¶ main",
     "last_opened_file_path": "D:/PycharmProjects/PythonProject1",
     "settings.editor.selected.configurable": "vcs.Git"
   }
